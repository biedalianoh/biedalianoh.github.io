<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javascript,vue," />





  <link rel="alternate" href="/atom.xml" title="Chavin's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="兼容性Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能实现的 ECMAScript 5 特性。
开发环境部署可参考使用 vue+webpack。
基本用法1234567891011&amp;lt;div id=&quot;app&quot;&amp;gt;  &amp;#123;&amp;#123;message&amp;#125;&amp;#125;  &amp;lt;input v-model=&quot;message&quot;&amp;gt;&amp;lt;/d">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue1.0用法详解">
<meta property="og:url" content="http://yoursite.com/2017/01/11/vue/index.html">
<meta property="og:site_name" content="Chavin's Blog">
<meta property="og:description" content="兼容性Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能实现的 ECMAScript 5 特性。
开发环境部署可参考使用 vue+webpack。
基本用法1234567891011&amp;lt;div id=&quot;app&quot;&amp;gt;  &amp;#123;&amp;#123;message&amp;#125;&amp;#125;  &amp;lt;input v-model=&quot;message&quot;&amp;gt;&amp;lt;/d">
<meta property="og:updated_time" content="2017-01-11T10:31:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue1.0用法详解">
<meta name="twitter:description" content="兼容性Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能实现的 ECMAScript 5 特性。
开发环境部署可参考使用 vue+webpack。
基本用法1234567891011&amp;lt;div id=&quot;app&quot;&amp;gt;  &amp;#123;&amp;#123;message&amp;#125;&amp;#125;  &amp;lt;input v-model=&quot;message&quot;&amp;gt;&amp;lt;/d">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: "",
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Vue1.0用法详解 | Chavin's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  

  <div class="container one-collumn  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Chavin's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">FE Notes</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      


      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Vue1.0用法详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-11T18:31:41+08:00" content="2017-01-11">
              2017-01-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><p>Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能实现的 ECMAScript 5 特性。</p>
<h1 id="开发环境部署"><a href="#开发环境部署" class="headerlink" title="开发环境部署"></a>开发环境部署</h1><p>可参考使用 <a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">vue+webpack</a>。</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">  &#123;&#123;message&#125;&#125;</div><div class="line">  &lt;input v-model=<span class="string">"message"</span>&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  ele: <span class="string">'#app'</span>,</div><div class="line">  data: &#123;</div><div class="line">    message: <span class="string">'hello'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">  &lt;li v-for=<span class="string">"todo in todos"</span>&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  ele: <span class="string">'#app'</span>,</div><div class="line">  data: &#123;</div><div class="line">    todos: [&#123;</div><div class="line">      text: <span class="string">'111'</span></div><div class="line">    &#125;, &#123;</div><div class="line">      text: <span class="string">'222'</span></div><div class="line">    &#125;]</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">  &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</div><div class="line">  &lt;button v-on:click=<span class="string">"reverseMessage"</span>&gt;Reverse Message&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  data: &#123;</div><div class="line">    message: <span class="string">'hello vue'</span></div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    reverseMessage: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">      this.message = this.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">  &lt;input v-model=<span class="string">"newTodo"</span> v-on:keyup.enter=<span class="string">"addTodo"</span>&gt;</div><div class="line">  &lt;ul&gt;</div><div class="line">    &lt;li v-for=<span class="string">"todo in todos"</span>&gt;</div><div class="line">      &lt;span&gt;&#123;&#123;todo.text&#125;&#125;&lt;/span&gt;</div><div class="line">      &lt;button v-on:click=<span class="string">"removeTodo(<span class="variable">$index</span>)"</span>&gt;X&lt;/button&gt;</div><div class="line">    &lt;/li&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  data: &#123;</div><div class="line">    newTodo: <span class="string">''</span>,</div><div class="line">    todos: [&#123;</div><div class="line">      text: <span class="string">'Add todos'</span></div><div class="line">    &#125;]</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    addTodo: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">      var text = this.newTodo.trim();</div><div class="line">      <span class="keyword">if</span>(text) &#123;</div><div class="line">        this.todos.push(&#123;text: text&#125;)</div><div class="line">        this.newTodo = <span class="string">''</span></div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    removeTodo: <span class="keyword">function</span>(index) &#123;</div><div class="line">      this.todos.splice(index, 1)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h1><p>一个 Vue 实例其实正是一个 MVVM 模式中所描述的 ViewModel - 因此在文档中经常会使用 vm 这个变量名。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">  //</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>每个 Vue 实例都会代理其 data 对象里所有的属性：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var data = &#123; a: 1 &#125;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">  data: data</div><div class="line">&#125;)</div><div class="line">vm.a === data.a // -&gt; <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>只有在 new Vue 中定义的属性才是被响应的，如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。即双向绑定只有预先定义好的数据。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>除了数据属性，Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的数据属性区分。例如：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var data = &#123; a: 1 &#125;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">  el: <span class="string">'#example'</span>,</div><div class="line">  data: data</div><div class="line">&#125;)</div><div class="line"></div><div class="line">vm.<span class="variable">$data</span> === data // -&gt; <span class="literal">true</span></div><div class="line">vm.<span class="variable">$el</span> === document.getElementById(<span class="string">'example'</span>) // -&gt; <span class="literal">true</span></div><div class="line"></div><div class="line">// <span class="variable">$watch</span> 是一个实例方法</div><div class="line">vm.<span class="variable">$watch</span>(<span class="string">'a'</span>, <span class="keyword">function</span> (newVal, oldVal) &#123;</div><div class="line">  // 这个回调将在 `vm.a`  改变后调用</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Vue 实例在创建时有一系列初始化步骤，并且把这些步骤的节点暴露出来。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">  data: &#123;</div><div class="line">    a: 1</div><div class="line">  &#125;,</div><div class="line">  created: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">    console.log(this.a);  // `this` 指向 vm 实例</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>也有一些其它的节点，在实例生命周期的不同阶段调用，如 compiled、 ready 、destroyed。</p>
<h1 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h1><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>使用 “Mustache” 语法（双大括号）<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<p>你也可以只处理单次插值，今后的数据变化就不会再引起插值更新了：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;span&gt;This will never change: &#123;&#123;* msg &#125;&#125;&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><blockquote>
<p>vue1.x中用法</p>
</blockquote>
<p>双 Mustache 标签将数据解析为纯文本而不是 HTML。为了输出真的 HTML 字符串，需要用三 Mustache 标签：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&#123;&#123;&#123; raw_html &#125;&#125;&#125;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>vue2.x中用法</p>
</blockquote>
<p>v-html<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-html=<span class="string">"raw_html"</span>&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="html标签属性"><a href="#html标签属性" class="headerlink" title="html标签属性"></a>html标签属性</h2><blockquote>
<p>vue1.x用法<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"item-&#123;&#123; id &#125;&#125;"</span>&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>vue2.x用法<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:id=<span class="string">"id"</span>&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="js表达式"><a href="#js表达式" class="headerlink" title="js表达式"></a>js表达式</h2><p>Vue.js 在数据绑定内支持全功能的 JavaScript 表达式：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; number + 1 &#125;&#125;</div><div class="line"></div><div class="line">&#123;&#123; ok ? <span class="string">'YES'</span> : <span class="string">'NO'</span> &#125;&#125;</div><div class="line"></div><div class="line">&#123;&#123; message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) &#125;&#125;</div></pre></td></tr></table></figure></p>
<p>这些表达式将在所属的 Vue 实例的作用域内计算。一个限制是每个绑定只能包含单个表达式，因此下面的语句是无效的：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 这是一个语句，不是一个表达式： --&gt;</div><div class="line">&#123;&#123; var a = 1 &#125;&#125;</div><div class="line"></div><div class="line">&lt;!-- 流程控制也不可以，可改用三元表达式 --&gt;</div><div class="line">&#123;&#123; <span class="keyword">if</span> (ok) &#123; <span class="built_in">return</span> message &#125; &#125;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器 |"></a>过滤器 |</h2><p>Vue.js 允许在表达式后添加可选的“过滤器 (Filter) ”，以“管道符”指示：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; message | capitalize &#125;&#125;</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  // ...</div><div class="line">  filters: &#123;</div><div class="line">    capitalize: <span class="keyword">function</span> (value) &#123;</div><div class="line">      <span class="keyword">if</span> (!value) <span class="built_in">return</span> <span class="string">''</span></div><div class="line">      value = value.toString()</div><div class="line">      <span class="built_in">return</span> value.charAt(0).toUpperCase() + value.slice(1)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Vue 2.x 中，过滤器只能在 mustache 绑定中使用。为了在指令绑定中实现同样的行为，你应该使用计算属性。<br>并且只能通过 Vue.filter 来定义</p>
</blockquote>
<p>Vue.js 需要通过自定义来使用。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// filter.vue</div><div class="line">&lt;script&gt;</div><div class="line">import Vue from <span class="string">'vue'</span></div><div class="line">Vue.filter(<span class="string">'myfilter'</span>, <span class="keyword">function</span> (value) &#123;</div><div class="line">  <span class="built_in">return</span> value + <span class="string">'-filter'</span></div><div class="line">&#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>过滤器可以串联：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</div></pre></td></tr></table></figure></p>
<p>过滤器也可以接受参数：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// message 为 filterA 的第一个参数，<span class="string">'arg1'</span> 字符串为第二个参数， arg2为变量参数</div><div class="line">&#123;&#123; message | filterA <span class="string">'arg1'</span> arg2 &#125;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="指令-v"><a href="#指令-v" class="headerlink" title="指令 v-"></a>指令 v-</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt; v-if=<span class="string">"greeting"</span>&gt;Hello&lt;/p&gt;</div></pre></td></tr></table></figure>
<p>有些指令可以在其名称后面带一个“参数” ，中间放一个冒号隔开<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;a v-bind:href=<span class="string">"url"</span>&gt;&lt;/a&gt;</div><div class="line">&lt;a v-on:click=<span class="string">"doSomething"</span>&gt;&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<p>还可添加修饰符，修饰符 (Modifiers) 是以半角句号 . 开始的特殊后缀，用于表示指令应当以特殊方式绑定。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//vue1.x有literal修饰符，vue2.x没有</div><div class="line">&lt;a v-bind:href.literal=<span class="string">"/a/b/c"</span>&gt;&lt;/a&gt;    // .literal 修饰符告诉指令将它的值解析为一个字面字符串而不是一个表达式</div></pre></td></tr></table></figure></p>
<h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>Vue.js 为两个最常用的指令 v-bind 和 v-on 提供特别的缩写。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 完整语法 --&gt;</div><div class="line">&lt;a v-bind:href=<span class="string">"url"</span>&gt;&lt;/a&gt;</div><div class="line">&lt;!-- 缩写 --&gt;</div><div class="line">&lt;a :href=<span class="string">"url"</span>&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;!-- 完整语法 --&gt;</div><div class="line">&lt;a v-on:click=<span class="string">"doSomething"</span>&gt;&lt;/a&gt;</div><div class="line">&lt;!-- 缩写 --&gt;</div><div class="line">&lt;a @click=<span class="string">"doSomething"</span>&gt;&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<h2 id="属性计算computed"><a href="#属性计算computed" class="headerlink" title="属性计算computed"></a>属性计算computed</h2><p>Vue提供了computed中的属性，其中的属性可以和data中的属性一样正常调用。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"example"</span>&gt;</div><div class="line">  a=&#123;&#123; a &#125;&#125;, b=&#123;&#123; b &#125;&#125;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var vm = new Vue(&#123;</div><div class="line">  el: <span class="string">'#example'</span>,</div><div class="line">  data: &#123;</div><div class="line">    a: 1</div><div class="line">  &#125;,</div><div class="line">  computed: &#123;</div><div class="line">    // 一个计算属性的 getter</div><div class="line">    b: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      <span class="built_in">return</span> this.a + 1</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>计算属性computed默认只是 getter，不过在需要时你也可以提供一个 setter：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// ...</div><div class="line">computed: &#123;</div><div class="line">  fullName: &#123;</div><div class="line">    // getter</div><div class="line">    get: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      <span class="built_in">return</span> this.firstName + <span class="string">' '</span> + this.lastName</div><div class="line">    &#125;,</div><div class="line">    // setter</div><div class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> (newValue) &#123;</div><div class="line">      var names = newValue.split(<span class="string">' '</span>)</div><div class="line">      this.firstName = names[0]</div><div class="line">      this.lastName = names[names.length - 1]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// ...</div></pre></td></tr></table></figure></p>
<p>现在在调用 vm.fullName = ‘John Doe’ 时， setter 会被调用， vm.firstName 和 vm.lastName 也会有相应更新。</p>
<h2 id="class绑定"><a href="#class绑定" class="headerlink" title="class绑定"></a>class绑定</h2><p>注意 v-bind:class 指令可以与普通的 class 特性共存：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div class=<span class="string">"static"</span> v-bind:class=<span class="string">"&#123; 'class-a': isA, 'class-b': isB &#125;"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">data: &#123;</div><div class="line">  isA: <span class="literal">true</span>,</div><div class="line">  isB: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以直接绑定数据里的一个对象：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:class=<span class="string">"classObject"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">data: &#123;</div><div class="line">  classObject: &#123;</div><div class="line">    <span class="string">'class-a'</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">'class-b'</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以把一个数组传给 v-bind:class，以应用一个 class 列表：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:class=<span class="string">"[classA, classB]"</span>&gt;</div><div class="line"></div><div class="line">data: &#123;</div><div class="line">  classA: <span class="string">'class-a'</span>,</div><div class="line">  classB: <span class="string">'class-b'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以组合使用：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:class=<span class="string">"[classA, &#123; classB: isB, classC: isC &#125;]"</span>&gt;</div></pre></td></tr></table></figure></p>
<h2 id="style绑定"><a href="#style绑定" class="headerlink" title="style绑定"></a>style绑定</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:style=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">data: &#123;</div><div class="line">  activeColor: <span class="string">'red'</span>,</div><div class="line">  fontSize: 30</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接绑定到一个样式对象通常更好，让模板更清晰：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:style=<span class="string">"styleObject"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">data: &#123;</div><div class="line">  styleObject: &#123;</div><div class="line">    color: <span class="string">'red'</span>,</div><div class="line">    fontSize: <span class="string">'13px'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以使用数组语法绑定style：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:style=<span class="string">"[styleObjectA, styleObjectB]"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>最后，当 v-bind:style 使用需要厂商前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。</p>
<h2 id="v-if-和-v-else"><a href="#v-if-和-v-else" class="headerlink" title="v-if 和 v-else"></a>v-if 和 v-else</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;h1 v-if=<span class="string">"ok"</span>&gt;Yes&lt;/h1&gt;</div><div class="line"></div><div class="line">&lt;h1 v-if=<span class="string">"ok"</span>&gt;Yes&lt;/h1&gt;</div><div class="line">&lt;h1 v-else&gt;No&lt;/h1&gt;</div></pre></td></tr></table></figure>
<p>在使用v-if对多个元素进行判断时，可以使用template, 并在template上进行判断。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;template v-if=<span class="string">"ok"</span>&gt;</div><div class="line">  &lt;h1&gt;Title&lt;/h1&gt;</div><div class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</div><div class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure></p>
<h2 id="v-show-和-v-else"><a href="#v-show-和-v-else" class="headerlink" title="v-show 和 v-else"></a>v-show 和 v-else</h2><p>用法和v-if类似，不过v-show的元素会保持在dom中，并且v-show不支持template语法。<br>并且 v-show 和 v-else 不要用在组件上，可以用两个 v-show 来进行判断。</p>
<h2 id="v-for循环"><a href="#v-for循环" class="headerlink" title="v-for循环"></a>v-for循环</h2><blockquote>
<p>vue1.x 中 v-for 有一个特殊变量 $index，是当前数组元素的索引：</p>
</blockquote>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=<span class="string">"example-2"</span>&gt;</div><div class="line">  &lt;li v-for=<span class="string">"item in items"</span>&gt;</div><div class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; <span class="variable">$index</span> &#125;&#125; - &#123;&#123; item.message &#125;&#125;</div><div class="line">  &lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p>另外，你可以为索引指定一个别名（如果 v-for 用于一个对象，则可以为对象的键指定一个别名）：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div v-for=<span class="string">"(item, key) in items"</span>&gt;</div><div class="line">  &#123;&#123; key &#125;&#125; &#123;&#123; item.message &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>从 1.0.17 开始可以使用 of 分隔符，更接近 JavaScript 遍历器语法：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-for=<span class="string">"item of items"</span>&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="template-v-for"><a href="#template-v-for" class="headerlink" title="template v-for"></a>template v-for</h2><blockquote>
<p>可以将 v-for 用在 <template> 标签上，以渲染一个包含多个元素的块。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">  &lt;template v-for=<span class="string">"item in items"</span>&gt;</div><div class="line">    &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;</div><div class="line">    &lt;li class=<span class="string">"divider"</span>&gt;&lt;/li&gt;</div><div class="line">  &lt;/template&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></template></p>
</blockquote>
<h2 id="v-for对象循环"><a href="#v-for对象循环" class="headerlink" title="v-for对象循环"></a>v-for对象循环</h2><p>也可以使用 v-for 遍历对象。除了 $index 之外，作用域内还可以访问另外一个特殊变量 $key。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=<span class="string">"repeat-object"</span> class=<span class="string">"demo"</span>&gt;</div><div class="line">  &lt;li v-for=<span class="string">"value in object"</span>&gt;</div><div class="line">    &#123;&#123; <span class="variable">$key</span> &#125;&#125; : &#123;&#123; value &#125;&#125;</div><div class="line">  &lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'#repeat-object'</span>,</div><div class="line">  data: &#123;</div><div class="line">    object: &#123;</div><div class="line">      FirstName: <span class="string">'John'</span>,</div><div class="line">      LastName: <span class="string">'Doe'</span>,</div><div class="line">      Age: 30</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>也可以给对象的键提供一个别名：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div v-for=<span class="string">"(key, val) in object"</span>&gt;</div><div class="line">  &#123;&#123; key &#125;&#125; &#123;&#123; val &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="v-for数字循环"><a href="#v-for数字循环" class="headerlink" title="v-for数字循环"></a>v-for数字循环</h2><p>v-for 也可以接收一个整数，此时它将重复模板数次。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;span v-for=<span class="string">"n in 10"</span>&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="数组变动渲染"><a href="#数组变动渲染" class="headerlink" title="数组变动渲染"></a>数组变动渲染</h2><p>Vue.js 包装了被观察数组的变异方法，故它们能触发视图更新。被包装的方法有：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">push()</div><div class="line">pop()</div><div class="line"><span class="built_in">shift</span>()</div><div class="line">unshift()</div><div class="line">splice()</div><div class="line">sort()</div><div class="line">reverse()</div></pre></td></tr></table></figure></p>
<p>也有没有被包装的方法，如 filter(), concat() 和 slice()，不会修改原始数组而是返回一个新数组。在使用非变异方法时，可以直接用新数组替换旧数组：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">example1.items = example1.items.filter(<span class="keyword">function</span> (item) &#123;</div><div class="line">  <span class="built_in">return</span> item.message.match(/Foo/)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>可能你觉得这将导致 Vue.js 弃用已有 DOM 并重新渲染整个列表——幸运的是并非如此。 Vue.js 实现了一些启发算法，以最大化复用 DOM 元素，因而用另一个数组替换数组是一个非常高效的操作。</p>
<h2 id="数组变动渲染-track-by"><a href="#数组变动渲染-track-by" class="headerlink" title="数组变动渲染 track-by"></a>数组变动渲染 track-by</h2><p>有时需要用全新对象（例如通过 API 调用创建的对象）替换数组，可能导致重新渲染整个列表。此时，便可以使用 track-by 特性给 Vue.js 一个提示，Vue.js 因而能尽可能地复用已有实例。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div v-for=<span class="string">"item in items"</span> track-by=<span class="string">"_uid"</span>&gt;</div><div class="line">  &lt;!-- content --&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&#123;</div><div class="line">  items: [</div><div class="line">    &#123; _uid: <span class="string">'88f869d'</span>, ... &#125;,</div><div class="line">    &#123; _uid: <span class="string">'7496c10'</span>, ... &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="数组变动渲染-问题点"><a href="#数组变动渲染-问题点" class="headerlink" title="数组变动渲染 问题点"></a>数组变动渲染 问题点</h2><p>因为 JavaScript 的限制，Vue.js 不能检测到下面数组变化：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm.items[0] = &#123;&#125;;       //1. 直接用索引设置元素</div><div class="line">vm.items.length = 0;    //2. 修改数据的长度</div><div class="line">Object.freeze();        //3. 数组的元素是对象并且被冻结</div></pre></td></tr></table></figure></p>
<p>为了解决问题 (1)，Vue.js 扩展了观察数组，Vue1.x为它添加了一个 $set() 方法：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 与 `example1.items[0] = ...` 相同，但是能触发视图更新</div><div class="line">example1.items.<span class="variable">$set</span>(0, &#123; childMsg: <span class="string">'Changed!'</span>&#125;)</div></pre></td></tr></table></figure></p>
<p>Vue2.x则使用如下方法：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.set(example1.items, 0, &#123;childMsg: <span class="string">'Changed!'</span>&#125;)</div><div class="line">或</div><div class="line">example1.items.splice(0, 1, &#123;childMsg: <span class="string">'Changed!'</span>&#125;)</div></pre></td></tr></table></figure></p>
<p>至于问题 (2)，只需用一个空数组替换 items。<br>除了 $set()， Vue.js 也为观察数组添加了 $remove() 方法，用于从目标数组中查找并删除元素，在内部它调用 splice()<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.items.<span class="variable">$remove</span>(item)</div></pre></td></tr></table></figure></p>
<p>问题（3），在遍历一个数组时，如果数组元素是对象并且对象用 Object.freeze() 冻结，你需要明确指定 track-by。在这种情况下如果 Vue.js 不能自动追踪对象，将给出一条警告。</p>
<h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><h2 id="绑定方法"><a href="#绑定方法" class="headerlink" title="绑定方法"></a>绑定方法</h2><p>用 v-on 指令监听 DOM 事件：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"example"</span>&gt;</div><div class="line">  &lt;button v-on:click=<span class="string">"greet"</span>&gt;Greet&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">methods: &#123;</div><div class="line">  greet: <span class="keyword">function</span> (event) &#123;</div><div class="line">    alert(<span class="string">'Hello '</span> + this.name + <span class="string">'!'</span>)   // 方法内 `this` 指向 vm</div><div class="line">    alert(event.target.tagName)   // `event` 是原生 DOM 事件</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="内联语句"><a href="#内联语句" class="headerlink" title="内联语句"></a>内联语句</h2><p>可以让绑定的方法带上参数：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"example-2"</span>&gt;</div><div class="line">  &lt;button v-on:click=<span class="string">"say('hi')"</span>&gt;Say Hi&lt;/button&gt;</div><div class="line">  &lt;button v-on:click=<span class="string">"say('what')"</span>&gt;Say What&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">methods: &#123;</div><div class="line">  say: <span class="keyword">function</span> (msg) &#123;</div><div class="line">    alert(msg)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event 把它传入方法：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;button v-on:click=<span class="string">"say('hello!', <span class="variable">$event</span>)"</span>&gt;Submit&lt;/button&gt;</div><div class="line"></div><div class="line">methods: &#123;</div><div class="line">  say: <span class="keyword">function</span> (msg, event) &#123;</div><div class="line">    // 现在我们可以访问原生事件对象</div><div class="line">    event.preventDefault()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理器中经常需要调用 event.preventDefault() 或 event.stopPropagation()，为了解决这个问题，Vue.js 为 v-on 提供两个 事件修饰符：.prevent 与 .stop。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 阻止单击事件冒泡 --&gt;</div><div class="line">&lt;a v-on:click.stop=<span class="string">"doThis"</span>&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;!-- 提交事件不再重载页面 --&gt;</div><div class="line">&lt;form v-on:submit.prevent=<span class="string">"onSubmit"</span>&gt;&lt;/form&gt;</div><div class="line"></div><div class="line">&lt;!-- 修饰符可以串联 --&gt;</div><div class="line">&lt;a v-on:click.stop.prevent=<span class="string">"doThat"</span>&gt;</div><div class="line"></div><div class="line">&lt;!-- 只有修饰符 --&gt;</div><div class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>1.0.16 添加了两个额外的修饰符：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 添加事件侦听器时使用 capture 模式 --&gt;</div><div class="line">&lt;div v-on:click.capture=<span class="string">"doThis"</span>&gt;...&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</div><div class="line">&lt;div v-on:click.self=<span class="string">"doThat"</span>&gt;...&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要检测 keyCode。Vue.js 允许为 v-on 添加按键修饰符：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;</div><div class="line">&lt;input v-on:keyup.13=<span class="string">"submit"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>记住所有的 keyCode 比较困难，Vue.js 为最常用的按键提供别名：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 同上 --&gt;</div><div class="line">&lt;input v-on:keyup.enter=<span class="string">"submit"</span>&gt;</div><div class="line"></div><div class="line">&lt;!-- 缩写语法 --&gt;</div><div class="line">&lt;input @keyup.enter=<span class="string">"submit"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>全部的按键别名：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">enter</div><div class="line">tab</div><div class="line">delete</div><div class="line">esc</div><div class="line">space</div><div class="line">up</div><div class="line">down</div><div class="line">left</div><div class="line">right</div></pre></td></tr></table></figure></p>
<p>1.0.8+： 支持单字母按键别名。<br>1.0.17+： 可以自定义按键别名：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 可以使用 @keyup.f1</div><div class="line">Vue.directive(<span class="string">'on'</span>).keyCodes.f1 = 112</div></pre></td></tr></table></figure></p>
<h1 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a>表单绑定</h1><p>表单绑定可以通过v-model来对 input, radio, select, checkbox, textarea来进行数据绑定。</p>
<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!-- input --&gt;</div><div class="line">&lt;span&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/span&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"message"</span> placeholder=<span class="string">"edit me"</span>&gt;</div></pre></td></tr></table></figure>
<h2 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!-- textarea --&gt;</div><div class="line">&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</div><div class="line">&lt;textarea v-model=<span class="string">"message"</span> placeholder=<span class="string">"add multiple lines"</span>&gt;&lt;/textarea&gt;</div></pre></td></tr></table></figure>
<h2 id="checkbox"><a href="#checkbox" class="headerlink" title="checkbox"></a>checkbox</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!-- checkbox --&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> id=<span class="string">"checkbox"</span> v-model=<span class="string">"checked"</span>&gt;</div><div class="line">&lt;label <span class="keyword">for</span>=<span class="string">"checkbox"</span>&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;</div></pre></td></tr></table></figure>
<h2 id="多个checkbox"><a href="#多个checkbox" class="headerlink" title="多个checkbox"></a>多个checkbox</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 多个checkbox --&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> id=<span class="string">"jack"</span> value=<span class="string">"Jack"</span> v-model=<span class="string">"checkedNames"</span>&gt;</div><div class="line">&lt;label <span class="keyword">for</span>=<span class="string">"jack"</span>&gt;Jack&lt;/label&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> id=<span class="string">"john"</span> value=<span class="string">"John"</span> v-model=<span class="string">"checkedNames"</span>&gt;</div><div class="line">&lt;label <span class="keyword">for</span>=<span class="string">"john"</span>&gt;John&lt;/label&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> id=<span class="string">"mike"</span> value=<span class="string">"Mike"</span> v-model=<span class="string">"checkedNames"</span>&gt;</div><div class="line">&lt;label <span class="keyword">for</span>=<span class="string">"mike"</span>&gt;Mike&lt;/label&gt;</div><div class="line">&lt;br&gt;</div><div class="line">&lt;span&gt;Checked names: &#123;&#123; checkedNames | json &#125;&#125;&lt;/span&gt;</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'...'</span>,</div><div class="line">  data: &#123;</div><div class="line">    checkedNames: []</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="radio"><a href="#radio" class="headerlink" title="radio"></a>radio</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- radio --&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"radio"</span> id=<span class="string">"one"</span> value=<span class="string">"One"</span> v-model=<span class="string">"picked"</span>&gt;</div><div class="line">&lt;label <span class="keyword">for</span>=<span class="string">"one"</span>&gt;One&lt;/label&gt;</div><div class="line">&lt;br&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"radio"</span> id=<span class="string">"two"</span> value=<span class="string">"Two"</span> v-model=<span class="string">"picked"</span>&gt;</div><div class="line">&lt;label <span class="keyword">for</span>=<span class="string">"two"</span>&gt;Two&lt;/label&gt;</div><div class="line">&lt;br&gt;</div><div class="line">&lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;</div></pre></td></tr></table></figure>
<h2 id="select单选"><a href="#select单选" class="headerlink" title="select单选"></a>select单选</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!-- select单选 --&gt;</div><div class="line">&lt;select v-model=<span class="string">"selected"</span>&gt;</div><div class="line">  &lt;option selected&gt;A&lt;/option&gt;</div><div class="line">  &lt;option&gt;B&lt;/option&gt;</div><div class="line">  &lt;option&gt;C&lt;/option&gt;</div><div class="line">&lt;/select&gt;</div><div class="line">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</div></pre></td></tr></table></figure>
<h2 id="select多选"><a href="#select多选" class="headerlink" title="select多选"></a>select多选</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- select多选 --&gt;</div><div class="line">&lt;select v-model=<span class="string">"selected"</span> multiple&gt;</div><div class="line">  &lt;option selected&gt;A&lt;/option&gt;</div><div class="line">  &lt;option&gt;B&lt;/option&gt;</div><div class="line">  &lt;option&gt;C&lt;/option&gt;</div><div class="line">&lt;/select&gt;</div><div class="line">&lt;br&gt;</div><div class="line">&lt;span&gt;Selected: &#123;&#123; selected | json &#125;&#125;&lt;/span&gt;</div></pre></td></tr></table></figure>
<h2 id="布尔值转字符串"><a href="#布尔值转字符串" class="headerlink" title="布尔值转字符串"></a>布尔值转字符串</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 布尔值设置字符串 --&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> v-model=<span class="string">"toggle"</span> v-bind:<span class="literal">true</span>-value=<span class="string">"a"</span> v-bind:<span class="literal">false</span>-value=<span class="string">"b"</span>&gt;</div><div class="line"></div><div class="line">vm.toggle === vm.a    // 当选中时</div><div class="line">vm.toggle === vm.b    // 当没有选中时</div></pre></td></tr></table></figure>
<h1 id="表单参数"><a href="#表单参数" class="headerlink" title="表单参数"></a>表单参数</h1><p>在html上设置相应功能参数。</p>
<h2 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h2><p>在默认情况下，v-model 在input 事件中同步输入框值与数据，可以添加一个特性 lazy，从而改到在 change 事件中同步：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 在 <span class="string">"change"</span> 而不是 <span class="string">"input"</span> 事件中更新 --&gt;</div><div class="line">&lt;input v-model=<span class="string">"msg"</span> lazy&gt;</div></pre></td></tr></table></figure></p>
<h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>如果想自动将用户的输入转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个特性 number：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input v-model=<span class="string">"age"</span> number&gt;</div></pre></td></tr></table></figure></p>
<h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>vue2.x中如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input v-model.trim=<span class="string">"msg"</span>&gt;</div></pre></td></tr></table></figure></p>
<h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><p>debounce 设置一个最小的延时，在每次敲击之后延时同步输入框的值与数据。如果每次更新都要进行高耗操作（例如在输入提示中 Ajax 请求），它较为有用。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input v-model=<span class="string">"msg"</span> debounce=<span class="string">"500"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>注意 debounce 参数不会延迟 input 事件：它延迟“写入”底层数据。因此在使用 debounce 时应当用 vm.$watch() 响应数据的变化。若想延迟 DOM 事件，应当使用 debounce 过滤器。</p>
<h1 id="CSS过渡"><a href="#CSS过渡" class="headerlink" title="CSS过渡"></a>CSS过渡</h1><p>Vue.js 会在适当的时机为你触发 CSS 过渡或动画，你也可以提供相应的 JavaScript 钩子函数在过渡过程中执行自定义的 DOM 操作。<br>为了应用过渡效果，需要在目标元素上使用 transition 特性：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-if=<span class="string">"show"</span> transition=<span class="string">"my-transition"</span>&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>transition 特性可以与下面资源一起用：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">v-if</div><div class="line">v-show</div><div class="line">v-for （只在插入和删除时触发，使用 vue-animated-list 插件）</div><div class="line">动态组件 （介绍见组件）</div><div class="line">在组件的根节点上，并且被 Vue 实例 DOM 方法（如 vm.<span class="variable">$appendTo</span>(el)）触发。</div></pre></td></tr></table></figure></p>
<p>当插入或删除带有过渡的元素时，Vue 将：</p>
<p>尝试以 ID “my-transition” 查找 JavaScript 过渡钩子对象——通过 Vue.transition(id, hooks) 或 transitions 选项注册。如果找到了，将在过渡的不同阶段调用相应的钩子。<br>自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。<br>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。</p>
<h2 id="CSS过渡示例"><a href="#CSS过渡示例" class="headerlink" title="CSS过渡示例"></a>CSS过渡示例</h2><p>vuejs为css过渡默认添加了一些过渡，也可以在某些行为上自定义添加过渡。<br>Vue1.x:<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-if=<span class="string">"show"</span> transition=<span class="string">"expand"</span>&gt;hello&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>Vue2.x:<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;transition name=<span class="string">"fade"</span>&gt;</div><div class="line">    &lt;p v-if=<span class="string">"show"</span>&gt;hello&lt;/p&gt;</div><div class="line">  &lt;/transition&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>然后为 .expand-transition, .expand-enter 和 .expand-leave 添加 CSS 规则:<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* 必需 */</div><div class="line">.expand-transition &#123;</div><div class="line">  transition: all .3s ease;</div><div class="line">  height: 30px;</div><div class="line">  padding: 10px;</div><div class="line">  background-color: <span class="comment">#eee;</span></div><div class="line">  overflow: hidden;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* .expand-enter 定义进入的开始状态 */</div><div class="line">/* .expand-leave 定义离开的结束状态 */</div><div class="line">.expand-enter, .expand-leave &#123;</div><div class="line">  height: 0;</div><div class="line">  padding: 0 10px;</div><div class="line">  opacity: 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以在同一元素上通过动态绑定实现不同的过渡：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div v-if=<span class="string">"show"</span> :transition=<span class="string">"transitionName"</span>&gt;hello&lt;/div&gt;</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'...'</span>,</div><div class="line">  data: &#123;</div><div class="line">    show: <span class="literal">false</span>,</div><div class="line">    transitionName: <span class="string">'fade'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>另外，可以提供 JavaScript 各个状态钩子:<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Vue.transition(<span class="string">'expand'</span>, &#123;</div><div class="line"></div><div class="line">  beforeEnter: <span class="keyword">function</span> (el) &#123;</div><div class="line">    el.textContent = <span class="string">'beforeEnter'</span></div><div class="line">  &#125;,</div><div class="line">  enter: <span class="keyword">function</span> (el) &#123;</div><div class="line">    el.textContent = <span class="string">'enter'</span></div><div class="line">  &#125;,</div><div class="line">  afterEnter: <span class="keyword">function</span> (el) &#123;</div><div class="line">    el.textContent = <span class="string">'afterEnter'</span></div><div class="line">  &#125;,</div><div class="line">  enterCancelled: <span class="keyword">function</span> (el) &#123;</div><div class="line">    // handle cancellation</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  beforeLeave: <span class="keyword">function</span> (el) &#123;</div><div class="line">    el.textContent = <span class="string">'beforeLeave'</span></div><div class="line">  &#125;,</div><div class="line">  leave: <span class="keyword">function</span> (el) &#123;</div><div class="line">    el.textContent = <span class="string">'leave'</span></div><div class="line">  &#125;,</div><div class="line">  afterLeave: <span class="keyword">function</span> (el) &#123;</div><div class="line">    el.textContent = <span class="string">'afterLeave'</span></div><div class="line">  &#125;,</div><div class="line">  leaveCancelled: <span class="keyword">function</span> (el) &#123;</div><div class="line">    // handle cancellation</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="过渡的css类名"><a href="#过渡的css类名" class="headerlink" title="过渡的css类名"></a>过渡的css类名</h2><p>类名的添加和切换取决于 transition 特性的值。比如 transition=”fade”，会有三个 CSS 类名：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.fade-transition 始终保留在元素上。</div><div class="line">.fade-enter 定义进入过渡的开始状态。只应用一帧然后立即删除。</div><div class="line">.fade-leave 定义离开过渡的结束状态。在离开过渡开始时生效，在它结束后删除。</div></pre></td></tr></table></figure></p>
<p>如果 transition 特性没有值，类名默认是 .v-transition, .v-enter 和 .v-leave。</p>
<h2 id="自定义过渡类名"><a href="#自定义过渡类名" class="headerlink" title="自定义过渡类名"></a>自定义过渡类名</h2><p>1.0.14 新增。<br>我们可以在过渡的 JavaScript 定义中声明自定义的 CSS 过渡类名。这些自定义类名会覆盖默认的类名。当需要和第三方的 CSS 动画库，比如 Animate.css 配合时会非常有用：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div v-show=<span class="string">"ok"</span> class=<span class="string">"animated"</span> transition=<span class="string">"bounce"</span>&gt;Watch me bounce&lt;/div&gt;</div><div class="line"></div><div class="line">Vue.transition(<span class="string">'bounce'</span>, &#123;</div><div class="line">  enterClass: <span class="string">'bounceInLeft'</span>,</div><div class="line">  leaveClass: <span class="string">'bounceOutRight'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="显式声明css过渡类型"><a href="#显式声明css过渡类型" class="headerlink" title="显式声明css过渡类型"></a>显式声明css过渡类型</h2><p>1.0.14 新增<br>Vue.js 需要给过渡元素添加事件侦听器来侦听过渡何时结束。基于所使用的 CSS，该事件要么是 transitionend，要么是 animationend。如果你只使用了两者中的一种，那么 Vue.js 将能够根据生效的 CSS 规则自动推测出对应的事件类型。但是，有些情况下一个元素可能需要同时带有两种类型的动画。比如你可能希望让 Vue 来触发一个 CSS animation，同时该元素在鼠标悬浮时又有 CSS transition 效果。这样的情况下，你需要显式地声明你希望 Vue 处理的动画类型 (animation 或是 transition)：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Vue.transition(<span class="string">'bounce'</span>, &#123;</div><div class="line">  // 该过渡效果将只侦听 `animationend` 事件</div><div class="line">  <span class="built_in">type</span>: <span class="string">'animation'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="过渡流程详解"><a href="#过渡流程详解" class="headerlink" title="过渡流程详解"></a>过渡流程详解</h2><p>当 show 属性改变时，Vue.js 将相应地插入或删除 <div> 元素，按照如下规则改变过渡的 CSS 类名：</div></p>
<ul>
<li>如果 show 变为 false，Vue.js 将：<ul>
<li>调用 beforeLeave 钩子；</li>
<li>添加 v-leave 类名到元素上以触发过渡；</li>
<li>调用 leave 钩子；</li>
<li>等待过渡结束（监听 transitionend 事件）；</li>
<li>从 DOM 中删除元素并删除 v-leave 类名；</li>
<li>调用 afterLeave 钩子。</li>
<li>如果 show 变为 true，Vue.js 将：</li>
</ul>
</li>
<li>调用 beforeEnter 钩子；<ul>
<li>添加 v-enter 类名到元素上；</li>
<li>把它插入 DOM；</li>
<li>调用 enter 钩子；</li>
<li>强制一次 CSS 布局，让 v-enter 确实生效。然后删除 v-enter 类名，以触发过渡，回到元素的原始状态；</li>
<li>等待过渡结束；</li>
<li>调用 afterEnter 钩子。<br>另外，如果在它的进入过渡还在进行中时删除元素，将调用 enterCancelled 钩子，以清理变动或 enter 创建的计时器。反过来对于离开过渡亦如是。<br>上面所有的钩子函数在调用时，它们的 this 均指向其所属的 Vue 实例。编译规则：过渡在哪个上下文中编译，它的 this 就指向哪个上下文。<br>最后，enter 和 leave 可以有第二个可选的回调参数，用于显式控制过渡如何结束。因此不必等待 CSS transitionend 事件， Vue.js 将等待你手工调用这个回调，以结束过渡。例如：<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">enter: <span class="keyword">function</span> (el) &#123;</div><div class="line">  // 没有第二个参数</div><div class="line">  // 由 CSS transitionend 事件决定过渡何时结束</div><div class="line">&#125;</div><div class="line"></div><div class="line">enter: <span class="keyword">function</span> (el, <span class="keyword">done</span>) &#123;</div><div class="line">  // 有第二个参数</div><div class="line">  // 过渡只有在调用 `<span class="keyword">done</span>` 时结束</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>当多个元素一起过渡时，Vue.js 会批量处理，只强制一次布局。</p>
<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p>CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;span v-show=<span class="string">"show"</span> transition=<span class="string">"bounce"</span>&gt;Look at me!&lt;/span&gt;</div><div class="line"></div><div class="line">.bounce-transition &#123;</div><div class="line">  display: inline-block; /* 否则 scale 动画不起作用 */</div><div class="line">&#125;</div><div class="line">.bounce-enter &#123;</div><div class="line">  animation: bounce-in .5s;</div><div class="line">&#125;</div><div class="line">.bounce-leave &#123;</div><div class="line">  animation: bounce-out .5s;</div><div class="line">&#125;</div><div class="line">@keyframes bounce-in &#123;</div><div class="line">  0% &#123;</div><div class="line">    transform: scale(0);</div><div class="line">  &#125;</div><div class="line">  50% &#123;</div><div class="line">    transform: scale(1.5);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    transform: scale(1);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@keyframes bounce-out &#123;</div><div class="line">  0% &#123;</div><div class="line">    transform: scale(1);</div><div class="line">  &#125;</div><div class="line">  50% &#123;</div><div class="line">    transform: scale(1.5);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    transform: scale(0);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Javascript过渡"><a href="#Javascript过渡" class="headerlink" title="Javascript过渡"></a>Javascript过渡</h1><p>也可以只使用 JavaScript 钩子，不用定义任何 CSS 规则。当只使用 JavaScript 过渡时，enter 和 leave 钩子需要调用 done 回调，否则它们将被同步调用，过渡将立即结束。<br>为 JavaScript 过渡显式声明 css: false 是个好主意，Vue.js 将跳过 CSS 检测。这样也会阻止无意间让 CSS 规则干扰过渡。<br>在下例中我们使用 jQuery 注册一个自定义的 JavaScript 过渡：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Vue.transition(<span class="string">'fade'</span>, &#123;</div><div class="line">  css: <span class="literal">false</span>,</div><div class="line">  enter: <span class="keyword">function</span> (el, <span class="keyword">done</span>) &#123;</div><div class="line">    // 元素已被插入 DOM</div><div class="line">    // 在动画结束后调用 <span class="keyword">done</span></div><div class="line">    $(el)</div><div class="line">      .css(<span class="string">'opacity'</span>, 0)</div><div class="line">      .animate(&#123; opacity: 1 &#125;, 1000, <span class="keyword">done</span>)</div><div class="line">  &#125;,</div><div class="line">  enterCancelled: <span class="keyword">function</span> (el) &#123;</div><div class="line">    $(el).stop()</div><div class="line">  &#125;,</div><div class="line">  leave: <span class="keyword">function</span> (el, <span class="keyword">done</span>) &#123;</div><div class="line">    // 与 enter 相同</div><div class="line">    $(el).animate(&#123; opacity: 0 &#125;, 1000, <span class="keyword">done</span>)</div><div class="line">  &#125;,</div><div class="line">  leaveCancelled: <span class="keyword">function</span> (el) &#123;</div><div class="line">    $(el).stop()</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>然后用 transition 特性中：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p transition=<span class="string">"fade"</span>&gt;&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<h1 id="渐近过渡"><a href="#渐近过渡" class="headerlink" title="渐近过渡"></a>渐近过渡</h1><p>transition 与 v-for 一起用时可以创建渐近过渡。给过渡元素添加一个特性 stagger, enter-stagger 或 leave-stagger：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-for=<span class="string">"item in list"</span> transition=<span class="string">"stagger"</span> stagger=<span class="string">"100"</span>&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>或者，提供一个钩子 stagger, enter-stagger 或 leave-stagger，以更好的控制：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.transition(<span class="string">'stagger'</span>, &#123;</div><div class="line">  stagger: <span class="keyword">function</span> (index) &#123;</div><div class="line">    // 每个过渡项目增加 50ms 延时</div><div class="line">    // 但是最大延时限制为 300ms</div><div class="line">    <span class="built_in">return</span> Math.min(300, index * 50)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。</p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>我们可以用 Vue.extend() 创建一个组件构造器：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var MyComponent = Vue.extend(&#123;</div><div class="line">  // 选项...</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>要把这个构造器用作组件，需要用 Vue.component(tag, constructor) 注册 ：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 全局注册组件，tag 为 my-component</div><div class="line">Vue.component(<span class="string">'my-component'</span>, MyComponent)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>对于自定义标签名字，Vue.js 不强制要求遵循 W3C 规则（小写，并且包含一个短杠），尽管遵循这个规则比较好。</p>
</blockquote>
<p>组件在注册之后，便可以在父实例的模块中以自定义元素 <my-component> 的形式使用。要确保在初始化根实例之前注册了组件：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"example"</span>&gt;</div><div class="line">  &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">// 定义</div><div class="line">var MyComponent = Vue.extend(&#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 注册</div><div class="line">Vue.component(<span class="string">'my-component'</span>, MyComponent)</div><div class="line"></div><div class="line">// 创建根实例</div><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'#example'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></my-component></p>
<p>渲染为：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"example"</span>&gt;</div><div class="line">  &lt;div&gt;A custom component!&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><p>不需要全局注册每个组件。可以让组件只能用在其它组件内，用实例选项 components 注册：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var Child = Vue.extend(&#123; /* ... */ &#125;)</div><div class="line"></div><div class="line">var Parent = Vue.extend(&#123;</div><div class="line">  template: <span class="string">'...'</span>,</div><div class="line">  components: &#123;</div><div class="line">    // &lt;my-component&gt; 只能用在父组件模板内</div><div class="line">    <span class="string">'my-component'</span>: Child</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这种封装也适用于其它资源，如指令、过滤器和过渡。</p>
<h2 id="注册语法糖"><a href="#注册语法糖" class="headerlink" title="注册语法糖"></a>注册语法糖</h2><p>为了让事件更简单，可以直接传入选项对象而不是构造器给 Vue.component() 和 component 选项。Vue.js 在背后自动调用 Vue.extend()：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 在一个步骤中扩展与注册</div><div class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 局部注册也可以这么做</div><div class="line">var Parent = Vue.extend(&#123;</div><div class="line">  components: &#123;</div><div class="line">    <span class="string">'my-component'</span>: &#123;</div><div class="line">      template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="组件选项注意"><a href="#组件选项注意" class="headerlink" title="组件选项注意"></a>组件选项注意</h2><p>传入 Vue 构造器的多数选项也可以用在 Vue.extend() 中，不过有两个特例： data 和 el。试想如果我们简单地把一个对象作为 data 选项传给 Vue.extend()：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var data = &#123; a: 1 &#125;</div><div class="line">var MyComponent = Vue.extend(&#123;</div><div class="line">  data: data</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这么做的问题是 MyComponent 所有的实例将共享同一个 data 对象！这基本不是我们想要的，因此我们应当使用一个函数作为 data 选项，让这个函数返回一个新对象：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var MyComponent = Vue.extend(&#123;</div><div class="line">  data: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    <span class="built_in">return</span> &#123; a: 1 &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>同理，el 选项用在 Vue.extend() 中时也须是一个函数。</p>
<h2 id="模版解析"><a href="#模版解析" class="headerlink" title="模版解析"></a>模版解析</h2><p>Vue 的模板是 DOM 模板，使用浏览器原生的解析器而不是自己实现一个。相比字符串模板，DOM 模板有一些好处，但是也有问题，它必须是有效的 HTML 片段。一些 HTML 元素对什么元素可以放在它里面有限制。常见的限制：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a 不能包含其它的交互元素（如按钮，链接）</div><div class="line">ul 和 ol 只能直接包含 li</div><div class="line">select 只能包含 option 和 optgroup</div><div class="line">table 只能直接包含 thead, tbody, tfoot, tr, caption, col, colgroup</div><div class="line">tr 只能直接包含 th 和 td</div></pre></td></tr></table></figure></p>
<p>在实际中，这些限制会导致意外的结果。尽管在简单的情况下它可能可以工作，但是你不能依赖自定义组件在浏览器验证之前的展开结果。例如<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;my-select&gt;&lt;option&gt;...&lt;/option&gt;&lt;/my-select&gt; 不是有效的模板，即使 my-select 组件最终展开为 &lt;select&gt;...&lt;/select&gt;。</div><div class="line">另一个结果是，自定义标签（包括自定义元素和特殊标签，如</div><div class="line">&lt;component&gt;、&lt;template&gt;、 &lt;partial&gt; ）不能用在 ul, select, table 等对内部元素有限制的标签内。放在这些元素内部的自定义标签将被提到元素的外面，因而渲染不正确。</div></pre></td></tr></table></figure></p>
<p>对于自定义元素，应当使用 is 特性：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;</div><div class="line">  &lt;tr is=<span class="string">"my-component"</span>&gt;&lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure></p>
<p>template 不能用在 table 内，这时应使用 tbody，table 可以有多个tbody：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;</div><div class="line">  &lt;tbody v-for=<span class="string">"item in items"</span>&gt;</div><div class="line">    &lt;tr&gt;Even row&lt;/tr&gt;</div><div class="line">    &lt;tr&gt;Odd row&lt;/tr&gt;</div><div class="line">  &lt;/tbody&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p>组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。<br>“prop” 是组件数据的一个字段，期望从父组件传下来。子组件需要显式地用 props 选项 声明 props：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'child'</span>, &#123;</div><div class="line">  // 声明 props</div><div class="line">  props: [<span class="string">'msg'</span>],</div><div class="line">  // prop 可以用在模板内</div><div class="line">  // 可以用 `this.msg` 设置</div><div class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>然后向它传入一个普通字符串：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;child msg=<span class="string">"hello!"</span>&gt;&lt;/child&gt;</div></pre></td></tr></table></figure></p>
<h2 id="动态Props"><a href="#动态Props" class="headerlink" title="动态Props"></a>动态Props</h2><p>类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 绑定动态 Props 到父组件的数据。每当父组件的数据变化时，也会传导给子组件：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;input v-model=<span class="string">"parentMsg"</span>&gt;</div><div class="line">  &lt;br&gt;</div><div class="line">  &lt;child v-bind:my-message=<span class="string">"parentMsg"</span>&gt;&lt;/child&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>使用 v-bind 的缩写语法通常更简单：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;child :my-message=<span class="string">"parentMsg"</span>&gt;&lt;/child&gt;</div></pre></td></tr></table></figure></p>
<p>初学者常犯的一个错误是使用字面量语法传递数值：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 传递了一个字符串 <span class="string">"1"</span> --&gt;</div><div class="line">&lt;comp some-prop=<span class="string">"1"</span>&gt;&lt;/comp&gt;</div></pre></td></tr></table></figure></p>
<p>因为它是一个字面 prop，它的值以字符串 “1” 而不是以实际的数字传下去。如果想传递一个实际的 JavaScript 数字，需要使用动态语法，从而让它的值被当作 JavaScript 表达式计算：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 传递实际的数字  --&gt;</div><div class="line">&lt;comp :some-prop=<span class="string">"1"</span>&gt;&lt;/comp&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Prop双向绑定"><a href="#Prop双向绑定" class="headerlink" title="Prop双向绑定"></a>Prop双向绑定</h2><p>prop 默认是单向绑定：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。不过，也可以使用 .sync 或 .once 绑定修饰符显式地强制双向或单次绑定：<br>比较语法：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 默认为单向绑定 --&gt;</div><div class="line">&lt;child :msg=<span class="string">"parentMsg"</span>&gt;&lt;/child&gt;</div><div class="line"></div><div class="line">&lt;!-- 双向绑定 Vue1.x   Vue2.x无此功能, 使用自定义事件传递数据回父组件 --&gt;</div><div class="line">&lt;child :msg.sync=<span class="string">"parentMsg"</span>&gt;&lt;/child&gt;</div><div class="line"></div><div class="line">&lt;!-- 单次绑定 Vue1.x   Vue2.x无此功能, 使用自定义事件传递数据回父组件 --&gt;</div><div class="line">&lt;child :msg.once=<span class="string">"parentMsg"</span>&gt;&lt;/child&gt;</div></pre></td></tr></table></figure></p>
<p>双向绑定会把子组件的 msg 属性同步回父组件的 parentMsg 属性。单次绑定在建立之后不会同步之后的变化。<br>注意如果 prop 是一个对象或数组，是按引用传递。在子组件内修改它会影响父组件的状态，不管是使用哪种绑定类型。</p>
<h2 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h2><p>组件可以为 props 指定验证要求。当组件给其他人使用时这很有用，因为这些验证要求构成了组件的 API，确保其他人正确地使用组件。此时 props 的值是一个<strong>对象</strong>，包含验证要求：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'example'</span>, &#123;</div><div class="line">  props: &#123;</div><div class="line">    // 基础类型检测 （`null` 意思是任何类型都可以）</div><div class="line">    propA: Number,</div><div class="line">    // 多种类型 (1.0.21+)</div><div class="line">    propM: [String, Number],</div><div class="line">    // 必需且是字符串</div><div class="line">    propB: &#123;</div><div class="line">      <span class="built_in">type</span>: String,</div><div class="line">      required: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    // 数字，有默认值</div><div class="line">    propC: &#123;</div><div class="line">      <span class="built_in">type</span>: Number,</div><div class="line">      default: 100</div><div class="line">    &#125;,</div><div class="line">    // 对象/数组的默认值应当由一个函数返回</div><div class="line">    propD: &#123;</div><div class="line">      <span class="built_in">type</span>: Object,</div><div class="line">      default: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">        <span class="built_in">return</span> &#123; msg: <span class="string">'hello'</span> &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    // 指定这个 prop 为双向绑定</div><div class="line">    // 如果绑定类型不对将抛出一条警告</div><div class="line">    propE: &#123;</div><div class="line">      twoWay: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    // 自定义验证函数</div><div class="line">    propF: &#123;</div><div class="line">      validator: <span class="keyword">function</span> (value) &#123;</div><div class="line">        <span class="built_in">return</span> value &gt; 10</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    // 转换函数（1.0.12 新增）</div><div class="line">    // 在设置值之前转换值</div><div class="line">    propG: &#123;</div><div class="line">      coerce: <span class="keyword">function</span> (val) &#123;</div><div class="line">        <span class="built_in">return</span> val + <span class="string">''</span> // 将值转换为字符串</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    propH: &#123;</div><div class="line">      coerce: <span class="keyword">function</span> (val) &#123;</div><div class="line">        <span class="built_in">return</span> JSON.parse(val) // 将 JSON 字符串转换为对象</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>type 可以是下面原生构造器：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String</div><div class="line">Number</div><div class="line">Boolean</div><div class="line">Function</div><div class="line">Object</div><div class="line">Array</div></pre></td></tr></table></figure></p>
<p>type 也可以是一个自定义构造器，使用 instanceof 检测。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当 prop 验证失败了，Vue 将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告。</div></pre></td></tr></table></figure></p>
<h2 id="camelCase-和-kebab-case"><a href="#camelCase-和-kebab-case" class="headerlink" title="camelCase 和 kebab-case"></a>camelCase 和 kebab-case</h2><p>HTML 特性不区分大小写。名字形式为 camelCase 的 prop 用作特性时，需要转为 kebab-case（短横线隔开）：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'child'</span>, &#123;</div><div class="line">  // camelCase <span class="keyword">in</span> JavaScript</div><div class="line">  props: [<span class="string">'myMessage'</span>],</div><div class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">&lt;!-- kebab-case <span class="keyword">in</span> HTML --&gt;</div><div class="line">&lt;child my-message=<span class="string">"hello!"</span>&gt;&lt;/child&gt;</div></pre></td></tr></table></figure></p>
<h2 id="父子组件通信-父链"><a href="#父子组件通信-父链" class="headerlink" title="父子组件通信-父链"></a>父子组件通信-父链</h2><p>子组件可以用 this.$parent 访问它的父组件。根实例的后代可以用 this.$root 访问它。父组件有一个数组 this.$children，包含它所有的子元素。<br>尽管可以访问父链上任意的实例，不过子组件应当避免直接依赖父组件的数据，尽量显式地使用 props 传递数据。另外，在子组件中修改父组件的状态是非常糟糕的做法，因为：</p>
<ol>
<li>这让父组件与子组件紧密地耦合；</li>
<li>只看父组件，很难理解父组件的状态。因为它可能被任意子组件修改！理想情况下，只有组件自己能修改它的状态。</li>
</ol>
<h2 id="父子组件通信-自定义事件"><a href="#父子组件通信-自定义事件" class="headerlink" title="父子组件通信-自定义事件"></a>父子组件通信-自定义事件</h2><p>Vue 实例实现了一个自定义事件接口，用于在组件树中通信。这个事件系统独立于原生 DOM 事件，用法也不同。<br>每个 Vue 实例都是一个事件触发器：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">使用 <span class="variable">$on</span>() 监听事件；</div><div class="line">使用 <span class="variable">$emit</span>() 在它上面触发事件；</div><div class="line">使用 <span class="variable">$dispatch</span>() 派发事件，事件沿着父链冒泡；   // Vue1.x适用，Vue2.x中使用vue.x</div><div class="line">使用 <span class="variable">$broadcast</span>() 广播事件，事件向下传导给所有的后代。  // Vue1.x适用，Vue2.x中使用vue.x</div></pre></td></tr></table></figure></p>
<p>不同于 DOM 事件，Vue 事件在冒泡过程中第一次触发回调之后自动停止冒泡，除非回调明确返回 true。<br>简单例子：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 子组件模板 --&gt;</div><div class="line">&lt;template id=<span class="string">"child-template"</span>&gt;</div><div class="line">  &lt;input v-model=<span class="string">"msg"</span>&gt;</div><div class="line">  &lt;button v-on:click=<span class="string">"notify"</span>&gt;Dispatch Event&lt;/button&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;!-- 父组件模板 --&gt;</div><div class="line">&lt;div id=<span class="string">"events-example"</span>&gt;</div><div class="line">  &lt;p&gt;Messages: &#123;&#123; messages | json &#125;&#125;&lt;/p&gt;</div><div class="line">  &lt;child&gt;&lt;/child&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">// 注册子组件</div><div class="line">// 将当前消息派发出去</div><div class="line">Vue.component(<span class="string">'child'</span>, &#123;</div><div class="line">  template: <span class="string">'#child-template'</span>,</div><div class="line">  data: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    <span class="built_in">return</span> &#123; msg: <span class="string">'hello'</span> &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    notify: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      <span class="keyword">if</span> (this.msg.trim()) &#123;</div><div class="line">        this.<span class="variable">$dispatch</span>(<span class="string">'child-msg'</span>, this.msg)</div><div class="line">        this.msg = <span class="string">''</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 初始化父组件</div><div class="line">// 将收到消息时将事件推入一个数组</div><div class="line">var parent = new Vue(&#123;</div><div class="line">  el: <span class="string">'#events-example'</span>,</div><div class="line">  data: &#123;</div><div class="line">    messages: []</div><div class="line">  &#125;,</div><div class="line">  // 在创建实例时 `events` 选项简单地调用 `<span class="variable">$on</span>`</div><div class="line">  events: &#123;</div><div class="line">    <span class="string">'child-msg'</span>: <span class="keyword">function</span> (msg) &#123;</div><div class="line">      // 事件回调内的 `this` 自动绑定到注册它的实例上</div><div class="line">      this.messages.push(msg)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h2><p>Vue2.x</p>
<h2 id="使用v-on绑定自定义事件"><a href="#使用v-on绑定自定义事件" class="headerlink" title="使用v-on绑定自定义事件"></a>使用v-on绑定自定义事件</h2><p>Vue1.x<br>上例非常好，不过从父组件的代码中不能直观的看到 “child-msg” 事件来自哪里。如果我们在模板中子组件用到的地方声明事件处理器会更好。为此子组件可以用 v-on 监听自定义事件：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;child v-on:child-msg=<span class="string">"handleIt"</span>&gt;&lt;/child&gt;</div></pre></td></tr></table></figure></p>
<p>这样就很清楚了：当子组件触发了 “child-msg” 事件，父组件的 handleIt 方法将被调用。所有影响父组件状态的代码放到父组件的 handleIt 方法中；子组件只关注触发事件。<br>Vue2.x<br>父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！<br>每个 Vue 实例都实现了事件接口(Events interface)，即：<br>使用 $on(eventName) 监听事件<br>使用 $emit(eventName) 触发事件<br>另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 父组件</div><div class="line">&lt;div id=<span class="string">"counter-event-example"</span>&gt;</div><div class="line">  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;</div><div class="line">  &lt;button-counter v-on:increment=<span class="string">"incrementTotal"</span>&gt;&lt;/button-counter&gt;</div><div class="line">  &lt;button-counter v-on:increment=<span class="string">"incrementTotal"</span>&gt;&lt;/button-counter&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'#counter-event-example'</span>,</div><div class="line">  data: &#123;</div><div class="line">    total: 0</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    incrementTotal: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      this.total += 1</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">// 子组件</div><div class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;button v-on:click="increment"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class="line">  data: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    <span class="built_in">return</span> &#123;</div><div class="line">      counter: 0</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    increment: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      this.counter += 1</div><div class="line">      this.<span class="variable">$emit</span>(<span class="string">'increment'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>若只想监听原生事件，则用 .native 修饰 v-on 。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;my-component v-on:click.native=<span class="string">"doTheThing"</span>&gt;&lt;/my-component&gt;</div></pre></td></tr></table></figure></p>
<h2 id="子组件索引"><a href="#子组件索引" class="headerlink" title="子组件索引"></a>子组件索引</h2><p>尽管有 props 和 events，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 v-ref 为子组件指定一个索引 ID。例如：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"parent"</span>&gt;</div><div class="line">  &lt;user-profile v-ref:profile&gt;&lt;/user-profile&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var parent = new Vue(&#123; el: <span class="string">'#parent'</span> &#125;)</div><div class="line">// 访问子组件</div><div class="line">var child = parent.<span class="variable">$refs</span>.profile</div></pre></td></tr></table></figure></p>
<p>v-ref 和 v-for 一起用时，ref 是一个数组或对象，包含相应的子组件。</p>
<h2 id="使用Slot分发内容"><a href="#使用Slot分发内容" class="headerlink" title="使用Slot分发内容"></a>使用Slot分发内容</h2><p>在使用组件时，常常要像这样组合它们：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;app&gt;</div><div class="line">  &lt;app-header&gt;&lt;/app-header&gt;</div><div class="line">  &lt;app-footer&gt;&lt;/app-footer&gt;</div><div class="line">&lt;/app&gt;</div></pre></td></tr></table></figure></p>
<p>注意两点：</p>
<ol>
<li><app> 组件不知道它的挂载点会有什么内容，挂载点的内容是由 <app> 的父组件决定的。</app></app></li>
<li><app> 组件很可能有它自己的模板。</app></li>
</ol>
<p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个处理称为内容分发（或 “transclusion”，如果你熟悉 Angular）。Vue.js 实现了一个内容分发 API，参照了当前 Web 组件规范草稿，使用特殊的 <slot> 元素作为原始内容的插槽。</slot></p>
<h2 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h2><p>在深入内容分发 API 之前，我们先明确内容的编译作用域。假定模板为：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;child-component&gt;</div><div class="line">  &#123;&#123; msg &#125;&#125;</div><div class="line">&lt;/child-component&gt;</div></pre></td></tr></table></figure></p>
<p>msg 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：</p>
<blockquote>
<p>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译</p>
</blockquote>
<p>一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 无效 --&gt;</div><div class="line">&lt;child-component v-show=<span class="string">"someChildProperty"</span>&gt;&lt;/child-component&gt;</div></pre></td></tr></table></figure></p>
<p>假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。<br>如果要绑定子组件内的指令到一个组件的根节点，应当在它的模板内这么做：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'child-component'</span>, &#123;</div><div class="line">  // 有效，因为是在正确的作用域内</div><div class="line">  template: <span class="string">'&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;'</span>,</div><div class="line">  data: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    <span class="built_in">return</span> &#123;</div><div class="line">      someChildProperty: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>类似地，分发内容是在父组件作用域内编译。</p>
<h2 id="单个Slot"><a href="#单个Slot" class="headerlink" title="单个Slot"></a>单个Slot</h2><p>父组件的内容将被抛弃，除非子组件模板包含 <slot>。如果子组件模板只有一个没有特性的 slot，父组件的整个内容将插到 slot 所在的地方并替换它。</slot></p>
<p><slot> 标签的内容视为回退内容。回退内容在子组件的作用域内编译，当宿主元素为空并且没有内容供插入时显示这个回退内容。<br>假定 my-component 组件有下面模板：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;h1&gt;This is my component!&lt;/h1&gt;</div><div class="line">  &lt;slot&gt;</div><div class="line">    如果没有分发内容则显示我。</div><div class="line">  &lt;/slot&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></slot></p>
<p>父组件模板：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;my-component&gt;</div><div class="line">  &lt;p&gt;This is some original content&lt;/p&gt;</div><div class="line">  &lt;p&gt;This is some more original content&lt;/p&gt;</div><div class="line">&lt;/my-component&gt;</div></pre></td></tr></table></figure></p>
<p>渲染结果：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;h1&gt;This is my component!&lt;/h1&gt;</div><div class="line">  &lt;p&gt;This is some original content&lt;/p&gt;</div><div class="line">  &lt;p&gt;This is some more original content&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="具名Slot"><a href="#具名Slot" class="headerlink" title="具名Slot"></a>具名Slot</h2><p><slot> 元素可以用一个特殊特性 name 配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素。<br>仍然可以有一个匿名 slot，它是默认 slot，作为找不到匹配的内容片段的回退插槽。如果没有默认的 slot，这些找不到匹配的内容片段将被抛弃。<br>例如，假定我们有一个 multi-insertion 组件，它的模板为：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;slot name=<span class="string">"one"</span>&gt;&lt;/slot&gt;</div><div class="line">  &lt;slot&gt;&lt;/slot&gt;</div><div class="line">  &lt;slot name=<span class="string">"two"</span>&gt;&lt;/slot&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></slot></p>
<p>父组件模板：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;multi-insertion&gt;</div><div class="line">  &lt;p slot=<span class="string">"one"</span>&gt;One&lt;/p&gt;</div><div class="line">  &lt;p slot=<span class="string">"two"</span>&gt;Two&lt;/p&gt;</div><div class="line">  &lt;p&gt;Default A&lt;/p&gt;</div><div class="line">&lt;/multi-insertion&gt;</div></pre></td></tr></table></figure></p>
<p>渲染结果为：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;p slot=<span class="string">"one"</span>&gt;One&lt;/p&gt;</div><div class="line">  &lt;p&gt;Default A&lt;/p&gt;</div><div class="line">  &lt;p slot=<span class="string">"two"</span>&gt;Two&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>在组合组件时，内容分发 API 是非常有用的机制。</p>
<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 <strong><component></component></strong> 元素，动态地绑定到它的 is 特性：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'body'</span>,</div><div class="line">  data: &#123;</div><div class="line">    currentView: <span class="string">'home'</span></div><div class="line">  &#125;,</div><div class="line">  components: &#123;</div><div class="line">    home: &#123; /* ... */ &#125;,</div><div class="line">    posts: &#123; /* ... */ &#125;,</div><div class="line">    archive: &#123; /* ... */ &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">&lt;component :is=<span class="string">"currentView"</span>&gt;</div><div class="line">  &lt;!-- 组件在 vm.currentview 变化时改变 --&gt;</div><div class="line">&lt;/component&gt;</div></pre></td></tr></table></figure></p>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;component :is=<span class="string">"currentView"</span> keep-alive&gt;</div><div class="line">  &lt;!-- 非活动组件将被缓存 --&gt;</div><div class="line">&lt;/component&gt;</div></pre></td></tr></table></figure></p>
<h2 id="activate钩子"><a href="#activate钩子" class="headerlink" title="activate钩子"></a>activate钩子</h2><p>在切换组件时，切入组件在切入前可能需要进行一些异步操作。为了控制组件切换时长，给切入组件添加 activate 钩子：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'activate-example'</span>, &#123;</div><div class="line">  activate: <span class="keyword">function</span> (<span class="keyword">done</span>) &#123;</div><div class="line">    var self = this</div><div class="line">    loadDataAsync(<span class="keyword">function</span> (data) &#123;</div><div class="line">      self.someData = data</div><div class="line">      <span class="keyword">done</span>()</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>注意 activate 钩子只作用于动态组件切换或静态组件初始化渲染的过程中，不作用于使用实例方法手工插入的过程中。</p>
<h2 id="transition-mode"><a href="#transition-mode" class="headerlink" title="transition-mode"></a>transition-mode</h2><p>transition-mode 特性用于指定两个动态组件之间如何过渡。<br>在默认情况下，进入与离开平滑地过渡。这个特性可以指定另外两种模式：</p>
<ol>
<li>in-out：新组件先过渡进入，等它的过渡完成之后当前组件过渡出去。</li>
<li>out-in：当前组件先过渡出去，等它的过渡完成之后新组件过渡进入。<br>示例：<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 先淡出再淡入 --&gt;</div><div class="line">&lt;component</div><div class="line">  :is=<span class="string">"view"</span></div><div class="line">  transition=<span class="string">"fade"</span></div><div class="line">  transition-mode=<span class="string">"out-in"</span>&gt;</div><div class="line">&lt;/component&gt;</div><div class="line"></div><div class="line">.fade-transition &#123;</div><div class="line">  transition: opacity .3s ease;</div><div class="line">&#125;</div><div class="line">.fade-enter, .fade-leave &#123;</div><div class="line">  opacity: 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ol>
<li>组件和v-for<br>自定义组件可以像普通元素一样直接使用 v-for：<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;my-component v-for=<span class="string">"item in items"</span>&gt;&lt;/my-component&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>但是，不能传递数据给组件，因为组件的作用域是孤立的。为了传递数据给组件，应当使用 props：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;my-component</div><div class="line">  v-for=<span class="string">"item in items"</span></div><div class="line">  :item=<span class="string">"item"</span></div><div class="line">  :index=<span class="string">"<span class="variable">$index</span>"</span>&gt;</div><div class="line">&lt;/my-component&gt;</div></pre></td></tr></table></figure></p>
<p>不自动把 item 注入组件的原因是这会导致组件跟当前 v-for 紧密耦合。显式声明数据来自哪里可以让组件复用在其它地方。</p>
<ol>
<li><p>编写可复用组件<br>在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。<br>Vue.js 组件 API 来自三部分——prop，事件和 slot：<br>prop 允许外部环境传递数据给组件；<br>事件 允许组件触发外部环境的 action；<br>slot 允许外部环境插入内容到组件的视图结构内。<br>使用 v-bind 和 v-on 的简写语法，模板的缩进清楚且简洁：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;my-component</div><div class="line">  :foo=<span class="string">"baz"</span></div><div class="line">  :bar=<span class="string">"qux"</span></div><div class="line">  @event<span class="_">-a</span>=<span class="string">"doThis"</span></div><div class="line">  @event-b=<span class="string">"doThat"</span>&gt;</div><div class="line">  &lt;!-- content --&gt;</div><div class="line">  &lt;img slot=<span class="string">"icon"</span> src=<span class="string">"..."</span>&gt;</div><div class="line">  &lt;p slot=<span class="string">"main-text"</span>&gt;Hello!&lt;/p&gt;</div><div class="line">&lt;/my-component&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>异步组件<br>在大型应用中，我们可能需要将应用拆分为小块，只在需要时才从服务器下载。为了让事情更简单，Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'async-example'</span>, <span class="keyword">function</span> (resolve, reject) &#123;</div><div class="line">  <span class="built_in">set</span>Timeout(<span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    resolve(&#123;</div><div class="line">      template: <span class="string">'&lt;div&gt;I am async!&lt;/div&gt;'</span></div><div class="line">    &#125;)</div><div class="line">  &#125;, 1000)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 Webpack 的代码分割功能：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="keyword">function</span> (resolve) &#123;</div><div class="line">  // 这个特殊的 require 语法告诉 webpack</div><div class="line">  // 自动将编译后的代码分割成不同的块，</div><div class="line">  // 这些块将通过 ajax 请求自动下载。</div><div class="line">  require([<span class="string">'./my-async-component'</span>], resolve)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<ol>
<li>资源命名约定<br>一些资源，如组件和指令，是以 HTML 特性或 HTML 自定义元素的形式出现在模板中。因为 HTML 特性的名字和标签的名字不区分大小写，所以资源的名字通常需使用 kebab-case 而不是 camelCase 的形式，这不大方便。<br>Vue.js 支持资源的名字使用 camelCase 或 PascalCase 的形式，并且在模板中自动将它们转为 kebab-case（类似于 prop 的命名约定）：<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 在组件定义中</div><div class="line">components: &#123;</div><div class="line">  // 使用 camelCase 形式注册</div><div class="line">  myComponent: &#123; /*... */ &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;!-- 在模板中使用 kebab-case 形式 --&gt;</div><div class="line">&lt;my-component&gt;&lt;/my-component&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>ES6 对象字面量缩写 也没问题：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// PascalCase</div><div class="line">import TextBox from <span class="string">'./components/text-box'</span>;</div><div class="line">import DropdownMenu from <span class="string">'./components/dropdown-menu'</span>;</div><div class="line"></div><div class="line"><span class="built_in">export</span> default &#123;</div><div class="line">  components: &#123;</div><div class="line">    // 在模板中写作 &lt;text-box&gt; 和 &lt;dropdown-menu&gt;</div><div class="line">    TextBox,</div><div class="line">    DropdownMenu</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>递归组件<br>组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以：<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var StackOverflow = Vue.extend(&#123;</div><div class="line">  name: <span class="string">'stack-overflow'</span>,</div><div class="line">  template:</div><div class="line">    <span class="string">'&lt;div&gt;'</span> +</div><div class="line">      // 递归地调用它自己</div><div class="line">      <span class="string">'&lt;stack-overflow&gt;&lt;/stack-overflow&gt;'</span> +</div><div class="line">    <span class="string">'&lt;/div&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面组件会导致一个错误 “max stack size exceeded”，所以要确保递归调用有终止条件。当使用 Vue.component() 全局注册一个组件时，组件 ID 自动设置为组件的 name 选项。</p>
<ol>
<li>片段实例<br>在使用 template 选项时，模板的内容将替换实例的挂载元素。因而推荐模板的顶级元素始终是单个元素。<br>不这么写模板：<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;root node 1&lt;/div&gt;</div><div class="line">&lt;div&gt;root node 2&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>推荐这么写：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  I have a single root node!</div><div class="line">  &lt;div&gt;node 1&lt;/div&gt;</div><div class="line">  &lt;div&gt;node 2&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>下面几种情况会让实例变成一个片断实例：</p>
<ul>
<li>模板包含多个顶级元素。</li>
<li>模板只包含普通文本。</li>
<li>模板只包含其它组件（其它组件可能是一个片段实例）。</li>
<li>模板只包含一个元素指令，如 <partial> 或 vue-router 的 <router-view>。</router-view></partial></li>
<li>模板根节点有一个流程控制指令，如 v-if 或 v-for。<br>这些情况让实例有未知数量的顶级元素，它将把它的 DOM 内容当作片断。片断实例仍然会正确地渲染内容。不过，它没有一个根节点，它的 $el 指向一个锚节点，即一个空的文本节点（在开发模式下是一个注释节点）。<br>但是更重要的是，组件元素上的非流程控制指令，非 prop 特性和过渡将被忽略，因为没有根元素供绑定：<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 不可以，因为没有根元素 --&gt;</div><div class="line">&lt;example v-show=<span class="string">"ok"</span> transition=<span class="string">"fade"</span>&gt;&lt;/example&gt;</div><div class="line"></div><div class="line">&lt;!-- props 可以 --&gt;</div><div class="line">&lt;example :prop=<span class="string">"someData"</span>&gt;&lt;/example&gt;</div><div class="line"></div><div class="line">&lt;!-- 流程控制可以，但是不能有过渡 --&gt;</div><div class="line">&lt;example v-if=<span class="string">"ok"</span>&gt;&lt;/example&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>当然片断实例有它的用处，不过通常给组件一个根节点比较好。它会保证组件元素上的指令和特性能正确地转换，同时性能也稍微好些。</p>
<h2 id="内联模板"><a href="#内联模板" class="headerlink" title="内联模板"></a>内联模板</h2><p>如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;my-component inline-template&gt;</div><div class="line">  &lt;p&gt;These are compiled as the component<span class="string">'s own template&lt;/p&gt;</span></div><div class="line">  &lt;p&gt;Not parent's transclusion content.&lt;/p&gt;</div><div class="line">&lt;/my-component&gt;</div></pre></td></tr></table></figure></p>
<p>但是 inline-template 让模板的作用域难以理解，并且不能缓存模板编译结果。最佳实践是使用 template 选项在组件内定义模板。</p>
<h1 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h1><h2 id="双向绑定原理-追踪变化"><a href="#双向绑定原理-追踪变化" class="headerlink" title="双向绑定原理-追踪变化"></a>双向绑定原理-追踪变化</h2><p>把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本。<br>用户看不到 getter/setters，但是在内部它们让 Vue.js 追踪依赖，在属性被访问和修改时通知变化。一个问题是在浏览器控制台打印数据对象时 getter/setter 的格式化不同，使用 vm.$log() 实例方法可以得到更友好的输出。<br>模板中每个指令/数据绑定都有一个对应的 watcher 对象，在计算过程中它把属性记录为依赖。之后当依赖的 setter 被调用时，会触发 watcher 重新计算 ，也就会导致它的关联指令更新 DOM。<br>模板中每个指令/数据绑定都有一个对应的 watcher 对象，在计算过程中它把属性记录为依赖。之后当依赖的 setter 被调用时，会触发 watcher 重新计算 ，也就会导致它的关联指令更新 DOM。</p>
<h2 id="变化检测问题"><a href="#变化检测问题" class="headerlink" title="变化检测问题"></a>变化检测问题</h2><p>受 ES5 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。例如：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ar data = &#123; a: 1 &#125;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">  data: data</div><div class="line">&#125;)</div><div class="line">// `vm.a` 和 `data.a` 现在是响应的</div><div class="line"></div><div class="line">vm.b = 2</div><div class="line">// `vm.b` 不是响应的</div><div class="line"></div><div class="line">data.b = 2</div><div class="line">// `data.b` 不是响应的</div></pre></td></tr></table></figure></p>
<p>不过，有办法在实例创建之后添加属性并且让它是响应的。<br>对于 Vue 实例，可以使用 $set(key, value) 实例方法：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vm.<span class="variable">$set</span>(<span class="string">'b'</span>, 2)</div><div class="line">// `vm.b` 和 `data.b` 现在是响应的</div></pre></td></tr></table></figure></p>
<p>对于普通数据对象，可以使用全局方法 Vue.set(object, key, value)：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Vue.set(data, <span class="string">'c'</span>, 3)</div><div class="line">// `vm.c` 和 `data.c` 现在是响应的</div></pre></td></tr></table></figure></p>
<p>有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 添加属性。但是，添加到对象上的新属性不会触发更新。这时可以创建一个新的对象，包含原对象的属性和新的属性：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 不使用 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</div><div class="line">this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;)</div></pre></td></tr></table></figure></p>
<p>也有一些数组相关的问题，之前已经在列表渲染中讲过。</p>
<h2 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h2><p>尽管 Vue.js 提供了 API 动态地添加响应属性，还是推荐在 data 对象上声明所有的响应属性。<br>不这么做：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line">// 然后添加 `msg`</div><div class="line">vm.<span class="variable">$set</span>(<span class="string">'msg'</span>, <span class="string">'Hello!'</span>)</div></pre></td></tr></table></figure></p>
<p>这么做：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">  data: &#123;</div><div class="line">    // 以一个空值声明 `msg`</div><div class="line">    msg: <span class="string">''</span></div><div class="line">  &#125;,</div><div class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line">// 然后设置 `msg`</div><div class="line">vm.msg = <span class="string">'Hello!'</span></div></pre></td></tr></table></figure></p>
<p>这么做有两个原因：</p>
<ol>
<li>data 对象就像组件状态的模式（schema）。在它上面声明所有的属性让组件代码更易于理解。</li>
<li>添加一个顶级响应属性会强制所有的 watcher 重新计算，因为它之前不存在，没有 watcher 追踪它。这么做性能通常是可以接受的（特别是对比 Angular 的脏检查），但是可以在初始化时避免。<h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2>Vue.js 默认异步更新 DOM。每当观察到数据变化时，Vue 就开始一个队列，将同一事件循环内所有的数据变化缓存起来。如果一个 watcher 被多次触发，只会推入一次到队列中。等到下一次事件循环，Vue 将清空队列，只进行必要的 DOM 更新。在内部异步队列优先使用 MutationObserver，如果不支持则使用 setTimeout(fn, 0)。<br>例如，设置了 vm.someData = ‘new value’，DOM 不会立即更新，而是在下一次事件循环清空队列时更新。我们基本不用关心这个过程，但是如果想在 DOM 状态更新后做点什么，这会有帮助。尽管 Vue.js 鼓励开发者沿着数据驱动的思路，避免直接修改 DOM，但是有时确实要这么做。为了在数据变化之后等待 Vue.js 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback) 。回调在 DOM 更新完成后调用。例如：<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"example"</span>&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</div><div class="line"></div><div class="line">var vm = new Vue(&#123;</div><div class="line">  el: <span class="string">'#example'</span>,</div><div class="line">  data: &#123;</div><div class="line">    msg: <span class="string">'123'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">vm.msg = <span class="string">'new message'</span> // 修改数据</div><div class="line">vm.<span class="variable">$el</span>.textContent === <span class="string">'new message'</span> // <span class="literal">false</span></div><div class="line">Vue.nextTick(<span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">  vm.<span class="variable">$el</span>.textContent === <span class="string">'new message'</span> // <span class="literal">true</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>vm.$nextTick() 这个实例方法比较方便，因为它不需要全局 Vue，它的回调的 this 自动绑定到当前 Vue 实例：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'example'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;'</span>,</div><div class="line">  data: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    <span class="built_in">return</span> &#123;</div><div class="line">      msg: <span class="string">'not updated'</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    updateMessage: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      this.msg = <span class="string">'updated'</span></div><div class="line">      console.log(this.<span class="variable">$el</span>.textContent) // =&gt; <span class="string">'not updated'</span></div><div class="line">      this.<span class="variable">$nextTick</span>(<span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">        console.log(this.<span class="variable">$el</span>.textContent) // =&gt; <span class="string">'updated'</span></div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="计算属性的奥秘"><a href="#计算属性的奥秘" class="headerlink" title="计算属性的奥秘"></a>计算属性的奥秘</h2><p>你应该注意到 Vue.js 的计算属性不是简单的 getter。计算属性持续追踪它的响应依赖。在计算一个计算属性时，Vue.js 更新它的依赖列表并缓存结果，只有当其中一个依赖发生了变化，缓存的结果才无效。因此，只要依赖不发生变化，访问计算属性会直接返回缓存的结果，而不是调用 getter。<br>为什么要缓存呢？假设我们有一个高耗计算属性 A，它要遍历一个巨型数组并做大量的计算。然后，可能有其它的计算属性依赖 A。如果没有缓存，我们将调用 A 的 getter 许多次，超过必要次数。<br>由于计算属性被缓存了，在访问它时 getter 不总是被调用。考虑下例：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">  data: &#123;</div><div class="line">    msg: <span class="string">'hi'</span></div><div class="line">  &#125;,</div><div class="line">  computed: &#123;</div><div class="line">    example: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      <span class="built_in">return</span> Date.now() + this.msg</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>计算属性 example 只有一个依赖：vm.msg。Date.now() 不是 响应依赖，因为它跟 Vue 的数据观察系统无关。因而，在访问 vm.example 时将发现时间戳不变，除非 vm.msg 变了。<br>有时希望 getter 不改变原有的行为，每次访问 vm.example 时都调用 getter。这时可以为指定的计算属性关闭缓存：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  example: &#123;</div><div class="line">    cache: <span class="literal">false</span>,</div><div class="line">    get: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      <span class="built_in">return</span> Date.now() + this.msg</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在每次访问 vm.example 时，时间戳都是新的。但是，只是在 JavaScript 中访问是这样的；数据绑定仍是依赖驱动的。如果在模块中这样绑定计算属性 ，只有响应依赖发生变化时才更新 DOM。</p>
<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><p>除了内置指令，Vue.js 也允许注册自定义指令。自定义指令提供一种机制将数据的变化映射为 DOM 行为。<br>可以用 Vue.directive(id, definition) 方法注册一个全局自定义指令，它接收两个参数指令 ID 与定义对象。也可以用组件的 directives 选项注册一个局部自定义指令。</p>
<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>定义对象可以提供几个钩子函数（都是可选的）：<br>bind：只调用一次，在指令第一次绑定到元素上时调用。<br>update： 在 bind 之后立即以初始值为参数第一次调用，之后每当绑定值变化时调用，参数为新值与旧值。<br>unbind：只调用一次，在指令从元素上解绑时调用。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Vue.directive(<span class="string">'my-directive'</span>, &#123;</div><div class="line">  <span class="built_in">bind</span>: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    // 准备工作</div><div class="line">    // 例如，添加事件处理器或只需要运行一次的高耗任务</div><div class="line">  &#125;,</div><div class="line">  update: <span class="keyword">function</span> (newValue, oldValue) &#123;</div><div class="line">    // 值更新时的工作</div><div class="line">    // 也会以初始值为参数调用一次</div><div class="line">  &#125;,</div><div class="line">  unbind: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    // 清理工作</div><div class="line">    // 例如，删除 <span class="built_in">bind</span>() 添加的事件监听器</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在注册之后，便可以在 Vue.js 模板中这样用（记着添加前缀 v-）：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-my-directive=<span class="string">"someValue"</span>&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>当只需要 update 函数时，可以传入一个函数替代定义对象：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.directive(<span class="string">'my-directive'</span>, <span class="keyword">function</span> (value) &#123;</div><div class="line">  // 这个函数用作 update()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="实例的指令属性"><a href="#实例的指令属性" class="headerlink" title="实例的指令属性"></a>实例的指令属性</h2><p>所有的钩子函数将被复制到实际的指令对象中，钩子内 this 指向这个指令对象。这个对象暴露了一些有用的属性：</p>
<ul>
<li>el: 指令绑定的元素。</li>
<li>vm: 拥有该指令的上下文 ViewModel。</li>
<li>expression: 指令的表达式，不包括参数和过滤器。</li>
<li>arg: 指令的参数。</li>
<li>name: 指令的名字，不包含前缀。</li>
<li>modifiers: 一个对象，包含指令的修饰符。</li>
<li>descriptor: 一个对象，包含指令的解析结果。<br>你应当将这些属性视为只读的，不要修改它们。你也可以给指令对象添加自定义属性，但是注意不要覆盖已有的内部属性。<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"demo"</span> v-demo:hello.a.b=<span class="string">"msg"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">Vue.directive(<span class="string">'demo'</span>, &#123;</div><div class="line">  <span class="built_in">bind</span>: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    console.log(<span class="string">'demo bound!'</span>)</div><div class="line">  &#125;,</div><div class="line">  update: <span class="keyword">function</span> (value) &#123;</div><div class="line">    this.el.innerHTML =</div><div class="line">      <span class="string">'name - '</span>       + this.name + <span class="string">'&lt;br&gt;'</span> +</div><div class="line">      <span class="string">'expression - '</span> + this.expression + <span class="string">'&lt;br&gt;'</span> +</div><div class="line">      <span class="string">'argument - '</span>   + this.arg + <span class="string">'&lt;br&gt;'</span> +</div><div class="line">      <span class="string">'modifiers - '</span>  + JSON.stringify(this.modifiers) + <span class="string">'&lt;br&gt;'</span> +</div><div class="line">      <span class="string">'value - '</span>      + value</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">var demo = new Vue(&#123;</div><div class="line">  el: <span class="string">'#demo'</span>,</div><div class="line">  data: &#123;</div><div class="line">    msg: <span class="string">'hello!'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//结果</div><div class="line">name-demo</div><div class="line">expression-msg</div><div class="line">argument-hello</div><div class="line">modifiers-&#123;<span class="string">"b"</span>:<span class="literal">true</span>,<span class="string">"a"</span>:<span class="literal">true</span>&#125;</div><div class="line">value-hello</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="指令对象参数传值"><a href="#指令对象参数传值" class="headerlink" title="指令对象参数传值"></a>指令对象参数传值</h2><p>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令可以使用任意合法的 JavaScript 表达式：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div v-demo=<span class="string">"&#123; color: 'white', text: 'hello!' &#125;"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">Vue.directive(<span class="string">'demo'</span>, <span class="keyword">function</span> (value) &#123;</div><div class="line">  console.log(value.color) // <span class="string">"white"</span></div><div class="line">  console.log(value.text) // <span class="string">"hello!"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="字面修饰符"><a href="#字面修饰符" class="headerlink" title="字面修饰符"></a>字面修饰符</h2><p>当指令使用了字面修饰符，它的值将按普通字符串处理并传递给 update 方法。update 方法将只调用一次，因为普通字符串不能响应数据变化。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div v-demo.literal=<span class="string">"foo bar baz"</span>&gt;</div><div class="line"></div><div class="line">Vue.directive(<span class="string">'demo'</span>, <span class="keyword">function</span> (value) &#123;</div><div class="line">  console.log(value) // <span class="string">"foo bar baz"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="元素指令"><a href="#元素指令" class="headerlink" title="元素指令"></a>元素指令</h2><p>有时我们想以自定义元素的形式使用指令，而不是以特性的形式。这与 Angular 的 “E” 指令非常相似。元素指令可以看做是一个轻量组件。可以像下面这样注册一个自定义元素指令：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vue.elementDirective(<span class="string">'my-directive'</span>, &#123;</div><div class="line">  // API 同普通指令</div><div class="line">  <span class="built_in">bind</span>: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    // 操作 this.el...</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>不这样写：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-my-directive&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>这样写：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;my-directive&gt;&lt;/my-directive&gt;</div></pre></td></tr></table></figure></p>
<p>元素指令不能接受参数或表达式，但是它可以读取元素的特性从而决定它的行为。<br>迥异于普通指令，元素指令是终结性的，这意味着，一旦 Vue 遇到一个元素指令，它将跳过该元素及其子元素——只有该元素指令本身可以操作该元素及其子元素。</p>
<h2 id="高级选项"><a href="#高级选项" class="headerlink" title="高级选项"></a>高级选项</h2><h3 id="params"><a href="#params" class="headerlink" title="params"></a>params</h3><p>自定义指令可以接收一个 params 数组，指定一个特性列表，Vue 编译器将自动提取绑定元素的这些特性。例如：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div v-example a=<span class="string">"hi"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">Vue.directive(<span class="string">'example'</span>, &#123;</div><div class="line">  params: [<span class="string">'a'</span>],</div><div class="line">  <span class="built_in">bind</span>: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    console.log(this.params.a) // -&gt; <span class="string">"hi"</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>此 API 也支持动态属性。this.params[key] 会自动保持更新。另外，可以指定一个回调，在值变化时调用：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div v-example v-bind:a=<span class="string">"someValue"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">Vue.directive(<span class="string">'example'</span>, &#123;</div><div class="line">  params: [<span class="string">'a'</span>],</div><div class="line">  paramWatchers: &#123;</div><div class="line">    a: <span class="keyword">function</span> (val, oldVal) &#123;</div><div class="line">      console.log(<span class="string">'a changed!'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>类似于 props，指令参数的名字在 JavaScript 中使用 camelCase 风格，在 HTML 中对应使用 kebab-case 风格。例如，假设在模板里有一个参数 disable-effect，在 JavaScript 里以 disableEffect 访问它。</p>
<h3 id="deep"><a href="#deep" class="headerlink" title="deep"></a>deep</h3><p>如果自定义指令用在一个对象上，当对象内部属性变化时要触发 update，则在指令定义对象中指定 deep: true。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div v-my-directive=<span class="string">"obj"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">Vue.directive(<span class="string">'my-directive'</span>, &#123;</div><div class="line">  deep: <span class="literal">true</span>,</div><div class="line">  update: <span class="keyword">function</span> (obj) &#123;</div><div class="line">    // 在 `obj` 的嵌套属性变化时调用</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="twoWay"><a href="#twoWay" class="headerlink" title="twoWay"></a>twoWay</h3><p>如果指令想向 Vue 实例写回数据，则在指令定义对象中指定 twoWay: true 。该选项允许在指令中使用 this.set(value):<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Vue.directive(<span class="string">'example'</span>, &#123;</div><div class="line">  twoWay: <span class="literal">true</span>,</div><div class="line">  <span class="built_in">bind</span>: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    this.handler = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      // 将数据写回 vm</div><div class="line">      // 如果指令这样绑定 v-example=<span class="string">"a.b.c"</span></div><div class="line">      // 它将用给定值设置 `vm.a.b.c`</div><div class="line">      this.set(this.el.value)</div><div class="line">    &#125;.bind(this)</div><div class="line">    this.el.addEventListener(<span class="string">'input'</span>, this.handler)</div><div class="line">  &#125;,</div><div class="line">  unbind: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    this.el.removeEventListener(<span class="string">'input'</span>, this.handler)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="acceptStatement"><a href="#acceptStatement" class="headerlink" title="acceptStatement"></a>acceptStatement</h3><p>传入 acceptStatement:true 可以让自定义指令接受内联语句，就像 v-on 那样：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div v-my-directive=<span class="string">"a++"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">Vue.directive(<span class="string">'my-directive'</span>, &#123;</div><div class="line">  acceptStatement: <span class="literal">true</span>,</div><div class="line">  update: <span class="keyword">function</span> (fn) &#123;</div><div class="line">    // 传入值是一个函数</div><div class="line">    // 在调用它时将在所属实例作用域内计算 <span class="string">"a++"</span> 语句</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>明智地使用，因为通常你要在模板中避免副效应。</p>
<h3 id="terminal"><a href="#terminal" class="headerlink" title="terminal"></a>terminal</h3><p>1.0.19+<br>Vue 通过递归遍历 DOM 树来编译模块。但是当它遇到 terminal 指令时会停止遍历这个元素的后代元素。这个指令将接管编译这个元素及其后代元素的任务。v-if 和 v-for 都是 terminal 指令。<br>编写自定义 terminal 指令是一个高级话题，需要较好的理解 Vue 的编译流程，但这不是说不可能编写自定义 terminal 指令。用 terminal: true 指定自定义 terminal 指令，可能还需要用 Vue.FragmentFactory 来编译 partial。下面是一个自定义 terminal 指令，它编译它的内容模板并将结果注入到页面的另一个地方：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var FragmentFactory = Vue.FragmentFactory</div><div class="line">var remove = Vue.util.remove</div><div class="line">var createAnchor = Vue.util.createAnchor</div><div class="line"></div><div class="line">Vue.directive(<span class="string">'inject'</span>, &#123;</div><div class="line">  terminal: <span class="literal">true</span>,</div><div class="line">  <span class="built_in">bind</span>: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    var container = document.getElementById(this.arg)</div><div class="line">    this.anchor = createAnchor(<span class="string">'v-inject'</span>)</div><div class="line">    container.appendChild(this.anchor)</div><div class="line">    remove(this.el)</div><div class="line">    var factory = new FragmentFactory(this.vm, this.el)</div><div class="line">    this.frag = factory.create(this._host, this._scope, this._frag)</div><div class="line">    this.frag.before(this.anchor)</div><div class="line">  &#125;,</div><div class="line">  unbind: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    this.frag.remove()</div><div class="line">    remove(this.anchor)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">&lt;div id=<span class="string">"modal"</span>&gt;&lt;/div&gt;</div><div class="line">...</div><div class="line">&lt;div v-inject:modal&gt;</div><div class="line">  &lt;h1&gt;header&lt;/h1&gt;</div><div class="line">  &lt;p&gt;body&lt;/p&gt;</div><div class="line">  &lt;p&gt;footer&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>如果你想编写自定义 terminal 指令，建议你通读内置 terminal 指令的源码，如 v-if 和 v-for，以便更好地了解 Vue 的内部机制。</p>
<h3 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h3><p>可以给指令指定一个优先级。如果没有指定，普通指令默认是 1000， terminal 指令默认是 2000。同一个元素上优先级高的指令会比其它指令处理得早一些。优先级一样的指令按照它在元素特性列表中出现的顺序依次处理，但是不能保证这个顺序在不同的浏览器中是一致的。<br>可以在 API 中查看内置指令的优先级。另外，流程控制指令 v-if 和 v-for 在编译过程中始终拥有最高的优先级。</p>
<h1 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h1><p>类似于自定义指令，可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vue.filter(<span class="string">'reverse'</span>, <span class="keyword">function</span> (value) &#123;</div><div class="line">  <span class="built_in">return</span> value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">&lt;!-- <span class="string">'abc'</span> =&gt; <span class="string">'cba'</span> --&gt;</div><div class="line">&lt;span v-text=<span class="string">"message | reverse"</span>&gt;&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<p>过滤器函数可以接收任意数量的参数：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vue.filter(<span class="string">'wrap'</span>, <span class="keyword">function</span> (value, begin, end) &#123;</div><div class="line">  <span class="built_in">return</span> begin + value + end</div><div class="line">&#125;)</div><div class="line"></div><div class="line">&lt;!-- <span class="string">'hello'</span> =&gt; <span class="string">'before hello after'</span> --&gt;</div><div class="line">&lt;span v-text=<span class="string">"message | wrap 'before' 'after'"</span>&gt;&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<h2 id="双向过滤器"><a href="#双向过滤器" class="headerlink" title="双向过滤器"></a>双向过滤器</h2><p>目前我们使用过滤器都是在把来自模型的值显示在视图之前转换它。不过也可以定义一个过滤器，在把来自视图（<input> 元素）的值写回模型之前转化它：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Vue.filter(<span class="string">'currencyDisplay'</span>, &#123;</div><div class="line">  // model -&gt; view</div><div class="line">  // 在更新 `&lt;input&gt;` 元素之前格式化值</div><div class="line">  <span class="built_in">read</span>: <span class="keyword">function</span>(val) &#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">'$'</span>+val.toFixed(2)</div><div class="line">  &#125;,</div><div class="line">  // view -&gt; model</div><div class="line">  // 在写回数据之前格式化值</div><div class="line">  write: <span class="keyword">function</span>(val, oldVal) &#123;</div><div class="line">    var number = +val.replace(/[^\d.]/g, <span class="string">''</span>)</div><div class="line">    <span class="built_in">return</span> isNaN(number) ? 0 : parseFloat(number.toFixed(2))</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h2><p>如果过滤器参数没有用引号包起来，则它会在当前 vm 作用域内动态计算。另外，过滤器函数的 this 始终指向调用它的 vm。例如：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;input v-model=<span class="string">"userInput"</span>&gt;</div><div class="line">&lt;span&gt;&#123;&#123;msg | concat userInput&#125;&#125;&lt;/span&gt;</div><div class="line"></div><div class="line">Vue.filter(<span class="string">'concat'</span>, <span class="keyword">function</span> (value, input) &#123;</div><div class="line">  // `input` === `this.userInput`</div><div class="line">  <span class="built_in">return</span> value + input</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>上例比较简单，也可以用表达式达到相同的结果，但是对于更复杂的逻辑——需要多于一个语句，这时需要将它放到计算属性或自定义过滤器中。<br>内置过滤器 filterBy 和 orderBy，根据所属 Vue 实例的当前状态，过滤/排序传入的数组。</p>
<h1 id="混合对象"><a href="#混合对象" class="headerlink" title="混合对象"></a>混合对象</h1><p>混合以一种灵活的方式为组件提供分布复用功能。混合对象可以包含任意的组件选项。当组件使用了混合对象时，混合对象的所有选项将被“混入”组件自己的选项中。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 定义一个混合对象</div><div class="line">var myMixin = &#123;</div><div class="line">  created: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    this.hello()</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    hello: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      console.log(<span class="string">'hello from mixin!'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义一个组件，使用这个混合对象</div><div class="line">var Component = Vue.extend(&#123;</div><div class="line">  mixins: [myMixin]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">var component = new Component() // -&gt; <span class="string">"hello from mixin!"</span></div></pre></td></tr></table></figure></p>
<h2 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a>选项合并</h2><p>当混合对象与组件包含同名选项时，这些选项将以适当的策略合并。例如，同名钩子函数被并入一个数组，因而都会被调用。另外，混合的钩子将在组件自己的钩子之前调用。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var mixin = &#123;</div><div class="line">  created: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    console.log(<span class="string">'mixin hook called'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  mixins: [mixin],</div><div class="line">  created: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    console.log(<span class="string">'component hook called'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// -&gt; <span class="string">"mixin hook called"</span></div><div class="line">// -&gt; <span class="string">"component hook called"</span></div></pre></td></tr></table></figure></p>
<p>值为对象的选项，如 methods, components 和 directives 将合并到同一个对象内。如果键冲突则组件的选项优先。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var mixin = &#123;</div><div class="line">  methods: &#123;</div><div class="line">    foo: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      console.log(<span class="string">'foo'</span>)</div><div class="line">    &#125;,</div><div class="line">    conflicting: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      console.log(<span class="string">'from mixin'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var vm = new Vue(&#123;</div><div class="line">  mixins: [mixin],</div><div class="line">  methods: &#123;</div><div class="line">    bar: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      console.log(<span class="string">'bar'</span>)</div><div class="line">    &#125;,</div><div class="line">    conflicting: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">      console.log(<span class="string">'from self'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">vm.foo() // -&gt; <span class="string">"foo"</span></div><div class="line">vm.bar() // -&gt; <span class="string">"bar"</span></div><div class="line">vm.conflicting() // -&gt; <span class="string">"from self"</span></div></pre></td></tr></table></figure></p>
<p>注意 Vue.extend() 使用同样的合并策略。</p>
<h2 id="全局混合"><a href="#全局混合" class="headerlink" title="全局混合"></a>全局混合</h2><p>也可以全局注册混合。小心使用！一旦全局注册混合，它会影响所有之后创建的 Vue 实例。如果使用恰当，可以为自定义选项注入处理逻辑：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 为 `myOption` 自定义选项注入一个处理器</div><div class="line">Vue.mixin(&#123;</div><div class="line">  created: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    var myOption = this.<span class="variable">$options</span>.myOption</div><div class="line">    <span class="keyword">if</span> (myOption) &#123;</div><div class="line">      console.log(myOption)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  myOption: <span class="string">'hello!'</span></div><div class="line">&#125;)</div><div class="line">// -&gt; <span class="string">"hello!"</span></div></pre></td></tr></table></figure></p>
<p>慎用全局混合，因为它影响到每个创建的 Vue 实例，包括第三方组件。在大多数情况下，它应当只用于自定义选项，就像上面示例一样。</p>
<h2 id="自定义选项合并策略"><a href="#自定义选项合并策略" class="headerlink" title="自定义选项合并策略"></a>自定义选项合并策略</h2><p>在合并自定义选项时，默认的合并策略是简单地覆盖已有值。如果想用自定义逻辑合并自定义选项，则向 Vue.config.optionMergeStrategies 添加一个函数：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.config.optionMergeStrategies.myOption = <span class="keyword">function</span> (toVal, fromVal) &#123;</div><div class="line">  // 返回 mergedVal</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于多数值为对象的选项，可以简单地使用 methods 所用的合并策略:<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var strategies = Vue.config.optionMergeStrategies</div><div class="line">strategies.myOption = strategies.methods</div></pre></td></tr></table></figure></p>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>插件通常会为 Vue 添加全局功能。插件的范围没有限制——通常是下面几种：</p>
<ol>
<li>添加全局方法或属性，如 vue-element</li>
<li>添加全局资源：指令/过滤器/过渡等，如 vue-touch</li>
<li>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。</li>
<li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-router<br>Vue.js 的插件应当有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MyPlugin.install = <span class="keyword">function</span> (Vue, options) &#123;</div><div class="line">  // 1. 添加全局方法或属性</div><div class="line">  Vue.myGlobalMethod = ...</div><div class="line">  // 2. 添加全局资源</div><div class="line">  Vue.directive(<span class="string">'my-directive'</span>, &#123;&#125;)</div><div class="line">  // 3. 添加实例方法</div><div class="line">  Vue.prototype.<span class="variable">$myMethod</span> = ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>通过 Vue.use() 全局方法使用插件：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 调用 `MyPlugin.install(Vue)`</div><div class="line">Vue.use(MyPlugin)</div></pre></td></tr></table></figure></p>
<p>也可以传入一个选项对象：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.use(MyPlugin, &#123; someOption: <span class="literal">true</span> &#125;)</div></pre></td></tr></table></figure></p>
<p>一些插件，如 vue-router，如果 Vue 是全局变量则自动调用 Vue.use()。不过在模块环境中应当始终显式调用 Vue.use()：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 通过 Browserify 或 Webpack 使用 CommonJS 兼容模块</div><div class="line">var Vue = require(<span class="string">'vue'</span>)</div><div class="line">var VueRouter = require(<span class="string">'vue-router'</span>)</div><div class="line"></div><div class="line">// 不要忘了调用此方法</div><div class="line">Vue.use(VueRouter)</div></pre></td></tr></table></figure></p>
<h2 id="已有插件-amp-工具"><a href="#已有插件-amp-工具" class="headerlink" title="已有插件&amp;工具"></a>已有插件&amp;工具</h2><ol>
<li><a href="https://github.com/vuejs/vue-router" target="_blank" rel="external">vue-router</a>：Vue.js 官方路由。与 Vue.js 内核深度整合，让构建单页应用易如反掌。</li>
<li><a href="https://github.com/vuejs/vue-resource" target="_blank" rel="external">vue-resource</a>：通过 XMLHttpRequest 或 JSONP 发起请求并处理响应。</li>
<li><a href="https://github.com/vuejs/vue-async-data" target="_blank" rel="external">vue-async-data</a>：异步加载数据插件。</li>
<li><a href="https://github.com/vuejs/vue-validator" target="_blank" rel="external">vue-validator</a>：表单验证插件。</li>
<li><a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="external">vue-devtools</a>：Chrome 开发者工具扩展，用于调试 Vue.js 应用。</li>
<li><a href="https://github.com/vuejs/vue-touch" target="_blank" rel="external">vue-touch</a>：使用 Hammer.js 添加触摸手势指令。</li>
<li><a href="https://github.com/vuejs/vue-element" target="_blank" rel="external">vue-element</a>：使用 Vue.js 注册自定义元素。</li>
<li><a href="https://github.com/vuejs/vue-animated-list" target="_blank" rel="external">vue-animated-list</a>：方便的为 v-for 渲染的列表添加动画。</li>
<li><a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="external">用户贡献的工具</a></li>
</ol>
<h1 id="vue使用心得"><a href="#vue使用心得" class="headerlink" title="vue使用心得"></a>vue使用心得</h1><h2 id="mount"><a href="#mount" class="headerlink" title="$mount"></a>$mount</h2><p>使vue实例挂载到元素上。</p>
<h2 id="new-Vue-中的component和template"><a href="#new-Vue-中的component和template" class="headerlink" title="new Vue 中的component和template"></a>new Vue 中的component和template</h2><p>component用来扩展HTML元素，封装可重用的代码。<br>在使用component时，需要注册组件构造器。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var App = Vue.extend(&#123;</div><div class="line">  //选项...</div><div class="line">&#125;)</div><div class="line">Vue.component(<span class="string">'app'</span>, App);</div></pre></td></tr></table></figure></p>
<p>使用component时，有两种方法：</p>
<ol>
<li><p>在html中直接使用。此时需要有上面的注册步骤</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"example"</span>&gt;</div><div class="line">  &lt;app&gt;&lt;/app&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>在new Vue初始化中使用。此时不需要上面的注册步骤</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'#example'</span>,</div><div class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</div><div class="line">  components: &#123;App&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h2><p>使用插件时，需要调用Vue.use()<br>另外插件的使用是直接插入到new Vue 的定义中。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import VueRouter from <span class="string">'vue-router'</span></div><div class="line">Vue.use(VueRouter);</div><div class="line">var router = new VueRouter(&#123;</div><div class="line">  mode: <span class="string">'history'</span>,</div><div class="line">  base: __dirname,</div><div class="line">  routes: routerConfig</div><div class="line">&#125;);</div><div class="line">new Vue(&#123;</div><div class="line">  router</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="vue-文件"><a href="#vue-文件" class="headerlink" title=".vue 文件"></a>.vue 文件</h2><p>.vue文件包含三种类型的标签： template， script， style<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;&lt;div&gt;121212&lt;/div&gt;&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">import App from <span class="string">'./app'</span></div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;style&gt;</div><div class="line">div&#123;width:100px&#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<h2 id="router中文件属性定义"><a href="#router中文件属性定义" class="headerlink" title="router中文件属性定义"></a>router中文件属性定义</h2><p>由于只有主文件中有new Vue的定义，因此原本有些因此在new中定义的属性和方法，需要到component中去定义。比如 data，computed，ready等。<br>其中data需要通过函数返回json来实现。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// header.vue</div><div class="line">&lt;template id=<span class="string">""</span>&gt;</div><div class="line">  &lt;div class=<span class="string">"header"</span> v-bind:id=<span class="string">"headerId"</span>&gt;</div><div class="line">    &lt;h2&gt;header  &#123;&#123;msg&#125;&#125;&lt;span v-html=<span class="string">"html_msg"</span>&gt;&lt;/span&gt;&#123;&#123;1 + 1&#125;&#125;&lt;/h2&gt;</div><div class="line">    &lt;div&gt;&#123;&#123;msg | myfilter | myfilter&#125;&#125;&lt;/div&gt;</div><div class="line">    &lt;div&gt;&lt;span v-if=<span class="string">"bool.t"</span>&gt;<span class="literal">true</span>&lt;/span&gt;&lt;span v-if=<span class="string">"bool.f"</span>&gt;<span class="keyword">if</span>&lt;/span&gt;&lt;span v-else&gt;<span class="keyword">else</span>&lt;/span&gt;&lt;/div&gt;</div><div class="line">    &lt;div&gt;&lt;a v-bind:href.literal=<span class="string">"link"</span>&gt;链接<span class="built_in">bind</span>&lt;/a&gt;&lt;a :href=<span class="string">"link"</span>&gt;链接&lt;/a&gt;&lt;a v-on:click=<span class="string">"myclick"</span>&gt;click on&lt;/a&gt;&lt;a @click=<span class="string">"myclick"</span>&gt;click&lt;/a&gt;&lt;/div&gt;</div><div class="line">    &lt;div&gt;&#123;&#123;computedMsg&#125;&#125;&lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line"><span class="built_in">export</span> default &#123;</div><div class="line">  <span class="function"><span class="title">data</span></span> () &#123;</div><div class="line">    <span class="built_in">return</span> &#123;</div><div class="line">      msg: <span class="string">'js Msg'</span>,</div><div class="line">      html_msg: <span class="string">'&lt;em&gt;htmlmsg&lt;/em&gt;'</span>,</div><div class="line">      headerId: <span class="string">'topHeader'</span>,</div><div class="line">      bool: &#123;</div><div class="line">        t: <span class="literal">true</span>, f: <span class="literal">false</span></div><div class="line">      &#125;,</div><div class="line">      link: <span class="string">'baidu.com'</span>,</div><div class="line">      <span class="function"><span class="title">myclick</span></span> () &#123;</div><div class="line">        window.alert(<span class="string">'click'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  computed: &#123;</div><div class="line">    <span class="function"><span class="title">computedMsg</span></span> () &#123;</div><div class="line">      <span class="built_in">return</span> this.msg + <span class="string">'computed'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag">#javascript</a>
          
            <a href="/tags/vue/" rel="tag">#vue</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/11/nodejs/" rel="next" title="Nodejs 极速上手">
                <i class="fa fa-chevron-left"></i> Nodejs 极速上手
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/01/11/createElement_method/" rel="prev" title="几种创建标签节点和属性的方法">
                几种创建标签节点和属性的方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="Chavin" />
          <p class="site-author-name" itemprop="name">Chavin</p>
          <p class="site-description motion-element" itemprop="description">争取明日不被后浪拍在沙滩上</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">59</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">71</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/biedalianoh" target="_blank">
                  
                    <i class="fa fa-globe"></i> Github
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/biedalian_oh" target="_blank">
                  
                    <i class="fa fa-globe"></i> weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.biedalianoh.com" target="_blank">
                  
                    <i class="fa fa-globe"></i> 个人站点
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#兼容性"><span class="nav-number">1.</span> <span class="nav-text">兼容性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#开发环境部署"><span class="nav-number">2.</span> <span class="nav-text">开发环境部署</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本用法"><span class="nav-number">3.</span> <span class="nav-text">基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#列表"><span class="nav-number">3.1.</span> <span class="nav-text">列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件"><span class="nav-number">3.2.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#综合使用"><span class="nav-number">3.3.</span> <span class="nav-text">综合使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原理讲解"><span class="nav-number">4.</span> <span class="nav-text">原理讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#属性"><span class="nav-number">4.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法"><span class="nav-number">4.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生命周期"><span class="nav-number">4.3.</span> <span class="nav-text">生命周期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据绑定"><span class="nav-number">5.</span> <span class="nav-text">数据绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文本"><span class="nav-number">5.1.</span> <span class="nav-text">文本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#html"><span class="nav-number">5.2.</span> <span class="nav-text">html</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#html标签属性"><span class="nav-number">5.3.</span> <span class="nav-text">html标签属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js表达式"><span class="nav-number">5.4.</span> <span class="nav-text">js表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤器"><span class="nav-number">5.5.</span> <span class="nav-text">过滤器 |</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令-v"><span class="nav-number">5.6.</span> <span class="nav-text">指令 v-</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缩写"><span class="nav-number">5.7.</span> <span class="nav-text">缩写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性计算computed"><span class="nav-number">5.8.</span> <span class="nav-text">属性计算computed</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class绑定"><span class="nav-number">5.9.</span> <span class="nav-text">class绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#style绑定"><span class="nav-number">5.10.</span> <span class="nav-text">style绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-if-和-v-else"><span class="nav-number">5.11.</span> <span class="nav-text">v-if 和 v-else</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-show-和-v-else"><span class="nav-number">5.12.</span> <span class="nav-text">v-show 和 v-else</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-for循环"><span class="nav-number">5.13.</span> <span class="nav-text">v-for循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#template-v-for"><span class="nav-number">5.14.</span> <span class="nav-text">template v-for</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-for对象循环"><span class="nav-number">5.15.</span> <span class="nav-text">v-for对象循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-for数字循环"><span class="nav-number">5.16.</span> <span class="nav-text">v-for数字循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组变动渲染"><span class="nav-number">5.17.</span> <span class="nav-text">数组变动渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组变动渲染-track-by"><span class="nav-number">5.18.</span> <span class="nav-text">数组变动渲染 track-by</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组变动渲染-问题点"><span class="nav-number">5.19.</span> <span class="nav-text">数组变动渲染 问题点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事件绑定"><span class="nav-number">6.</span> <span class="nav-text">事件绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定方法"><span class="nav-number">6.1.</span> <span class="nav-text">绑定方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联语句"><span class="nav-number">6.2.</span> <span class="nav-text">内联语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件修饰符"><span class="nav-number">6.3.</span> <span class="nav-text">事件修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#按键修饰符"><span class="nav-number">6.4.</span> <span class="nav-text">按键修饰符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#表单绑定"><span class="nav-number">7.</span> <span class="nav-text">表单绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#input"><span class="nav-number">7.1.</span> <span class="nav-text">input</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#textarea"><span class="nav-number">7.2.</span> <span class="nav-text">textarea</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#checkbox"><span class="nav-number">7.3.</span> <span class="nav-text">checkbox</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多个checkbox"><span class="nav-number">7.4.</span> <span class="nav-text">多个checkbox</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#radio"><span class="nav-number">7.5.</span> <span class="nav-text">radio</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select单选"><span class="nav-number">7.6.</span> <span class="nav-text">select单选</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select多选"><span class="nav-number">7.7.</span> <span class="nav-text">select多选</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布尔值转字符串"><span class="nav-number">7.8.</span> <span class="nav-text">布尔值转字符串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#表单参数"><span class="nav-number">8.</span> <span class="nav-text">表单参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#lazy"><span class="nav-number">8.1.</span> <span class="nav-text">lazy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#number"><span class="nav-number">8.2.</span> <span class="nav-text">number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#trim"><span class="nav-number">8.3.</span> <span class="nav-text">trim</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#debounce"><span class="nav-number">8.4.</span> <span class="nav-text">debounce</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CSS过渡"><span class="nav-number">9.</span> <span class="nav-text">CSS过渡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS过渡示例"><span class="nav-number">9.1.</span> <span class="nav-text">CSS过渡示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过渡的css类名"><span class="nav-number">9.2.</span> <span class="nav-text">过渡的css类名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义过渡类名"><span class="nav-number">9.3.</span> <span class="nav-text">自定义过渡类名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#显式声明css过渡类型"><span class="nav-number">9.4.</span> <span class="nav-text">显式声明css过渡类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过渡流程详解"><span class="nav-number">9.5.</span> <span class="nav-text">过渡流程详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS动画"><span class="nav-number">9.6.</span> <span class="nav-text">CSS动画</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Javascript过渡"><span class="nav-number">10.</span> <span class="nav-text">Javascript过渡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#渐近过渡"><span class="nav-number">11.</span> <span class="nav-text">渐近过渡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组件"><span class="nav-number">12.</span> <span class="nav-text">组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#注册"><span class="nav-number">12.1.</span> <span class="nav-text">注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部注册"><span class="nav-number">12.2.</span> <span class="nav-text">局部注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注册语法糖"><span class="nav-number">12.3.</span> <span class="nav-text">注册语法糖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件选项注意"><span class="nav-number">12.4.</span> <span class="nav-text">组件选项注意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模版解析"><span class="nav-number">12.5.</span> <span class="nav-text">模版解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Props"><span class="nav-number">12.6.</span> <span class="nav-text">Props</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态Props"><span class="nav-number">12.7.</span> <span class="nav-text">动态Props</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prop双向绑定"><span class="nav-number">12.8.</span> <span class="nav-text">Prop双向绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prop验证"><span class="nav-number">12.9.</span> <span class="nav-text">Prop验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#camelCase-和-kebab-case"><span class="nav-number">12.10.</span> <span class="nav-text">camelCase 和 kebab-case</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#父子组件通信-父链"><span class="nav-number">12.11.</span> <span class="nav-text">父子组件通信-父链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#父子组件通信-自定义事件"><span class="nav-number">12.12.</span> <span class="nav-text">父子组件通信-自定义事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非父子组件通信"><span class="nav-number">12.13.</span> <span class="nav-text">非父子组件通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用v-on绑定自定义事件"><span class="nav-number">12.14.</span> <span class="nav-text">使用v-on绑定自定义事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子组件索引"><span class="nav-number">12.15.</span> <span class="nav-text">子组件索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Slot分发内容"><span class="nav-number">12.16.</span> <span class="nav-text">使用Slot分发内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译作用域"><span class="nav-number">12.17.</span> <span class="nav-text">编译作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单个Slot"><span class="nav-number">12.18.</span> <span class="nav-text">单个Slot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#具名Slot"><span class="nav-number">12.19.</span> <span class="nav-text">具名Slot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态组件"><span class="nav-number">12.20.</span> <span class="nav-text">动态组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keep-alive"><span class="nav-number">12.21.</span> <span class="nav-text">keep-alive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#activate钩子"><span class="nav-number">12.22.</span> <span class="nav-text">activate钩子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#transition-mode"><span class="nav-number">12.23.</span> <span class="nav-text">transition-mode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#杂项"><span class="nav-number">12.24.</span> <span class="nav-text">杂项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联模板"><span class="nav-number">12.25.</span> <span class="nav-text">内联模板</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入响应式原理"><span class="nav-number">13.</span> <span class="nav-text">深入响应式原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#双向绑定原理-追踪变化"><span class="nav-number">13.1.</span> <span class="nav-text">双向绑定原理-追踪变化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变化检测问题"><span class="nav-number">13.2.</span> <span class="nav-text">变化检测问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化数据"><span class="nav-number">13.3.</span> <span class="nav-text">初始化数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步更新队列"><span class="nav-number">13.4.</span> <span class="nav-text">异步更新队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算属性的奥秘"><span class="nav-number">13.5.</span> <span class="nav-text">计算属性的奥秘</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义指令"><span class="nav-number">14.</span> <span class="nav-text">自定义指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#钩子函数"><span class="nav-number">14.1.</span> <span class="nav-text">钩子函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例的指令属性"><span class="nav-number">14.2.</span> <span class="nav-text">实例的指令属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令对象参数传值"><span class="nav-number">14.3.</span> <span class="nav-text">指令对象参数传值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字面修饰符"><span class="nav-number">14.4.</span> <span class="nav-text">字面修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元素指令"><span class="nav-number">14.5.</span> <span class="nav-text">元素指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级选项"><span class="nav-number">14.6.</span> <span class="nav-text">高级选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#params"><span class="nav-number">14.6.1.</span> <span class="nav-text">params</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deep"><span class="nav-number">14.6.2.</span> <span class="nav-text">deep</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#twoWay"><span class="nav-number">14.6.3.</span> <span class="nav-text">twoWay</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acceptStatement"><span class="nav-number">14.6.4.</span> <span class="nav-text">acceptStatement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#terminal"><span class="nav-number">14.6.5.</span> <span class="nav-text">terminal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority"><span class="nav-number">14.6.6.</span> <span class="nav-text">priority</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义过滤器"><span class="nav-number">15.</span> <span class="nav-text">自定义过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#双向过滤器"><span class="nav-number">15.1.</span> <span class="nav-text">双向过滤器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态参数"><span class="nav-number">15.2.</span> <span class="nav-text">动态参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#混合对象"><span class="nav-number">16.</span> <span class="nav-text">混合对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#选项合并"><span class="nav-number">16.1.</span> <span class="nav-text">选项合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局混合"><span class="nav-number">16.2.</span> <span class="nav-text">全局混合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义选项合并策略"><span class="nav-number">16.3.</span> <span class="nav-text">自定义选项合并策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#插件"><span class="nav-number">17.</span> <span class="nav-text">插件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用插件"><span class="nav-number">17.1.</span> <span class="nav-text">使用插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#已有插件-amp-工具"><span class="nav-number">17.2.</span> <span class="nav-text">已有插件&工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vue使用心得"><span class="nav-number">18.</span> <span class="nav-text">vue使用心得</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mount"><span class="nav-number">18.1.</span> <span class="nav-text">$mount</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-Vue-中的component和template"><span class="nav-number">18.2.</span> <span class="nav-text">new Vue 中的component和template</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插件的使用"><span class="nav-number">18.3.</span> <span class="nav-text">插件的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-文件"><span class="nav-number">18.4.</span> <span class="nav-text">.vue 文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#router中文件属性定义"><span class="nav-number">18.5.</span> <span class="nav-text">router中文件属性定义</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chavin</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.scheme !== 'Pisces' && (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always')) {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  
  


</body>
</html>
